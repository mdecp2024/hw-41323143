var tipuesearch = {"pages": [{'title': 'About', 'text': '國立虎尾科技大學機械設計工程系 \n National Formosa University \n Department of Mechanical Design Engineering \n cp2024 計算機程式 \n 課程教材: \n Learn Python with Jupyter  ( site ,  ebook ) \n 教育版帳號\xa0microsoftonline 登入點:\xa0 https://login.microsoftonline.com/ \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入  https://login.microsoftonline.com/  Office 365 \n Teams 團隊代碼:  ldodwua \n 個人倉儲: https://github.com/mdecp2024/hw-41323143 \n 個人網站: https://mdecp2024.github.io/hw-41323143/content/index.html \n 其他資訊: \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n', 'tags': '', 'url': 'About.html'}, {'title': 'Attendance', 'text': '出席 (10%) - 自行舉證評分 \n 自行利用 Github commits 提交記錄評分. \n', 'tags': '', 'url': 'Attendance.html'}, {'title': 'HW 1', 'text': '主題: 基於瀏覽器的分散式版次管理與整合程式開發環境 (10%) \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n Jupyter \n What are Github and Codespaces? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 1 \n \n PART 1: Creating the basics 資料整理 (10%) \n 啟動可攜程式系統後, 在命令列中: \n y:\\>cd notebook \n y:\\notebook>jupyter lab --collaborative \n 進入  01_string_input_print.ipynb  練習如何修改 PART1 notebook 後存檔, 上傳至作業倉儲中的 downloads 目錄後, 透過  https://nbviewer.org/  將已經提交的  01_string_input_print.ipynb , 嵌入下列網頁中. \n \n 上列 iframe 標註的 html 語法: \n <iframe width="600" height="400" src="https://nbviewer.org/urls/mde.tw/cp2024_hw/downloads/01_string_input_print.ipynb"></iframe> \n 完成上述流程整理後, 請將 HW1 自評分數輸入 cp2024 自評表單中. \n \n', 'tags': '', 'url': 'HW 1.html'}, {'title': 'HW 1 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 Topic 1 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 1 Exam.html'}, {'title': 'w7', 'text': '\n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w9', 'text': "#help(range)\nfor i in range(1,5):\n    print(i)\ndef print_pyramid(n):\n    for i in range(n):\n        # 打印空格\n        print(' ' * (n - i - 1), end='')\n        # 打印星號\n        print('*' * (2 * i + 1))\n\n# 設定金字塔的高度\nheight = 5\nprint_pyramid(height)\n \n 1\n2\n3\n4\n    *\n   ***\n  *****\n *******\n*********\n>Exit code: 0 \n   \n", 'tags': '', 'url': 'w9.html'}, {'title': 'w10', 'text': '\n \n \n \n 變數名稱不能使用關鍵字 ： 關鍵字（Keywords）是 Python 保留用來表示特定語法的詞，不能用來當作變數名稱。例如， for 、 while 、 if  等詞語具有特定的功能，無法用作變數名稱。 \n \n \n 變數名稱區分大小寫 ： Python 的變數名稱是大小寫敏感的， age  和  Age  會被視為兩個不同的變數名稱。這意味著在命名變數時需小心，以避免因大小寫不同而造成混淆。 \n \n \n 遵循 PEP 8 命名規範 ： \n \n 一般變數和函數名稱應使用 小寫字母 ，並用底線  _  分隔多個單字（例如： user_name ）。 \n 常數（固定不變的值）名稱通常使用 大寫字母 ，並用底線  _  分隔（例如： MAX_LIMIT ）。 \n 類別名稱則使用駝峰命名法（CamelCase），即首字母和每個新單字的首字母大寫（例如： StudentInfo ）。 \n \n \n \n 避免覆蓋內建函數名稱 ： Python 有許多內建函數和物件名稱，如  print 、 sum 、 list  等，這些名稱具有特定的功能。如果使用相同名稱定義變數，會覆蓋這些內建功能，造成程式錯誤或意料之外的行為。例如，如果將變數命名為  print ，則內建的  print()  函數會被覆蓋，之後的  print()  將無法正常使用。 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n \n \xa0 \n \n \xa0心得:讓我更熟悉了 \n \n \n', 'tags': '', 'url': 'w10.html'}, {'title': 'w11_hw', 'text': '1.\xa0 已知可以用 Python 程式 由上往下列印三角形 * , 或 由左往右列印三角形 * , 請將此程式延伸到可以在 10x10 的字元區域中, 以 "*" 字元列印出圓型區域. 完成後請將程式碼存入個人 Gist 後, 直接在個人作業網站中的 Brython 頁面中執行. (提示: ?src=gist_script_URL) \n 第一題:  以 "*" 字元列印出圓型區域 \n # 設定圓心與半徑\nh, k = 5, 5  # 圓心位置 (5, 5)\nr = 4         # 圓的半徑\n\n# 10x10 的字元區域\nfor y in range(1, 11):  # y 軸從 1 到 10\n    line = ""\n    for x in range(1, 11):  # x 軸從 1 到 10\n        # 計算該點 (x, y) 到圓心的距離\n        distance = ((x - h) ** 2 + (y - k) ** 2) ** 0.5\n        # 如果距離小於或等於半徑，則打印 "*"，以形成實心圓形\n        if distance <= r:\n            line += "＊"  # 使用全形星號\n        else:\n            line += "\u3000"  # 使用全形空格\n    print(line)\n \n \n 2. 已知可以在網頁中利用 Brython 繪製方格與塗色, 如下連結, 請設法修改此一程式, 直接將程式存入個人的 Gist, 並利用黑色方塊圍出一個圓形區域. \n 第二題: 網頁上的方格與塗色 \n \n from browser import html\nfrom browser import document as doc\nimport math\n\n# Create canvas element\ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = doc["brython_div1"]\nbrython_div <= canvas\n\n# Each grid square\'s pixel size\ngs = 20\nradius = 5  # Set the radius of the circle\ncx, cy = 5, 5  # Set the center of the circle (in grid coordinates)\n\n# Get the drawing context\nctx = canvas.getContext("2d")\n\ndef dRect(lux, luy, w, h, s=1, c=\'#ff0000\'):\n    ctx.lineWidth = s\n    ctx.strokeStyle = c\n    ctx.beginPath()\n    ctx.rect(lux, luy, w, h)\n    ctx.stroke()\n\ndef grid(width, height, grid_pix):\n    # Create grid with width x height number of grid cells\n    for i in range(width):\n        for j in range(height):\n            dRect(i * grid_pix, j * grid_pix, grid_pix, grid_pix, 1, "lightgrey")\n\ndef fill(x, y, color):\n    # Fill the grid cell with the specified color\n    ctx.fillStyle = color\n    ctx.fillRect(x - 1, y - 1, gs, gs)\n\ndef draw_filled_circle(radius, cx, cy):\n    # Create a filled circle using grid squares\n    for i in range(10):  # Iterate over the grid width (10 squares)\n        for j in range(10):  # Iterate over the grid height (10 squares)\n            # Calculate the center of the current grid square\n            center_x = i + 0.5\n            center_y = j + 0.5\n            # Check if this grid square falls inside the circle\n            if (center_x - cx) ** 2 + (center_y - cy) ** 2 <= radius ** 2:\n                fill(i * gs, j * gs, "black")  # Fill with black\n\n# Draw the grid\ngrid(10, 10, 20)\n\n# Draw a filled circle at the center (cx, cy) with the specified radius\ndraw_filled_circle(radius, cx, cy)\n \n \n 3. 完成上列題目後, 請利用 Youtube 影片 簡報 個人的解題過程與心得. \n \n', 'tags': '', 'url': 'w11_hw.html'}, {'title': 'w12_hw', 'text': '1. 請各組組員分別利用 \xa0 Brython 以及 Jupyter lab \xa0 環境, 執行 可攜程式 \xa0 notebook 目錄中的 \xa0 01_string_input_print.ipynb 至\xa010_for_search.ipynb \xa0 筆記本程式, 完成後請將能在 Brython 執行的程式碼存入個人 \xa0 Gist \xa0 後, 將各程式執行連結放入 w12_hw 網頁上. 最後請說明各範例中所使用的程式語法以及執行心得. \n 第一題: input與 print \n \xa0 input範例程式： 你叫啥 \n \xa0 說明: 顯示提示訊息 「你叫啥」,等待使用者輸入,將使用者輸入的內容（字串形式）傳回。\xa0 \n input("你叫啥 ") \n print 範例程式： 貓咪 \n 說明： print()  函式： \n 用來在終端（或控制台）中顯示內容。 \n 每行的內容由雙引號（或單引號）包裹。 \n 每行的內容解析： print(" /\\_/\\ ") ： 顯示貓耳朵和頭部的上半部分： /\\_/\\ 。 \n print(" >^.^< ") ： 顯示貓咪的臉部： >^.^< 。 \n print(" / \\\\ ") ： 顯示貓咪的身體底部和爪子的形狀： / \\ 。 注意：這裡的  \\\\  是為了顯示單個反斜槓  \\ ，因為\xa0 反斜槓在 Python 中是特殊字符（用於轉義）。 \n print(" (___)___") ： 顯示貓咪的身體和尾巴的樣式。 \n print (" /\\_/\\   ")\nprint (" >^.^<   ")\nprint ("  / \\    ")\nprint (" (___)___") \n \n 第二題:variables \n 2-1範例: 名字 \n 說明:這段程式碼定義兩個字串變數  first_name  和  last_name ，分別儲存名字和姓氏，然後用  print()  函式輸出這些值。 \n first_name = "Fernando"  # 定義變數 first_name，內容是字串 "Fernando"\nlast_name  = "Pérez"     # 定義變數 last_name，內容是字串 "Pérez"\nprint(first_name)        # 將變數 first_name 的內容輸出到終端\nprint(last_name)         # 將變數 last_name 的內容輸出到終端 \n 2-2範例: 名子+喜歡的食物 \n 說明:一個簡單的互動式程式，功能是詢問使用者名字和最喜歡的食物，然後輸出相關訊息。 \n name = input("What\'s your name? ")  # 提示使用者輸入名字\nfavorite_food = input("What is your favorite food? ")  # 提示使用者輸入最喜歡的食物\n\nprint("Hi! My name is " + name)  # 顯示名字\nprint("My favorite food is " + favorite_food)  # 顯示最喜歡的食物\nprint(name + "\'s favorite food is " + favorite_food)  # 顯示完整句子\n \n \xa0第三題:list_if_in_else \n 範例: 購買書籍 \n 說明:程式碼會顯示一個書籍清單，然後詢問使用者想購買的書籍。如果使用者選擇的書籍在清單中，程式會顯示「有售」，否則顯示「無售」。 \n programming_books = ["Learn python", "Python for all", "Intro to python"]  # 定義書籍清單\nprint(programming_books)  # 顯示可選擇的書籍\n\nwanted_book = input("Hi! What book would you like to buy?")  # 提示使用者輸入想購買的書籍名稱\nprint(wanted_book)  # 顯示使用者輸入的書籍名稱\n\n# 判斷書籍是否在可購買清單中\nif wanted_book in programming_books:\n    print("Yes, we sell it!")  # 書籍在清單中，顯示有售\nelse:\n    print("Sorry, we don\'t sell that book")  # 書籍不在清單中，顯示無售 \n 第四題:list_append_remove \n 範例: 購物清單 \n 說明:顯示目前的購物清單,提示使用者輸入想要新增的項目。 \n 如果該項目已經在清單中，顯示已存在；如果沒有，將其添加到清單中,提示使用者輸入要刪除的項目。 \n 如果該項目存在於清單中，就將其刪除，並顯示更新後的清單。如果該項目不在清單中，顯示錯誤訊息。 \n shopping_list = ["carrots", "chocolate", "olives"]  # 初始購物清單\nprint(shopping_list)  # 顯示當前購物清單\n\nnew_item = input("What else do I have to buy?")  # 提示使用者輸入想買的物品\n\n# 檢查新項目是否已在清單中\nif new_item in shopping_list:\n    print(new_item + " is/are already in the shopping list")  # 如果已有此項目，顯示提示\n    print(shopping_list)  # 顯示目前的清單\nelse:\n    shopping_list.append(new_item)  # 否則將新項目加入清單\n    print(shopping_list)  # 顯示更新後的清單\n\nitem_to_remove = input("What do I have to remove?")  # 提示使用者輸入要刪除的物品\n\n# 檢查要刪除的項目是否在清單中\nif item_to_remove in shopping_list:\n    shopping_list.remove(item_to_remove)  # 如果在清單中，將其刪除\n    print(shopping_list)  # 顯示更新後的清單\nelse:\n    print(item_to_remove + " is/are not in the list")  # 如果不在清單中，顯示錯誤訊息\n    print(shopping_list)  # 顯示未變動的清單\n \n \n \n', 'tags': '', 'url': 'w12_hw.html'}, {'title': 'w13_hw', 'text': '\n w13 作業 \n 請在下列圖形中的兩個正方形外圍, 以黑色畫筆畫圓, 並設法在各線條所圍成的封閉區域塗上不同顏色. 操作過程請拍攝影片, 並在頁面中列出作業心得. \n  導入 brython 程式庫  \n \n \n \n \n \n \n \n \n from browser import html\nfrom browser import document as doc\n\n# 創建畫布元素\ncanvas = html.CANVAS(width=500, height=500)\nbrython_div = doc["brython_div1"]\nbrython_div <= canvas\n\n# 定義圓心和半徑\nx1, y1 = 200, 200  # 第一個圓的圓心\nx2, y2 = 300, 300  # 第二個圓的圓心\nradius = 141.4  # 圓的半徑\n\nctx = canvas.getContext("2d")\n\n# 繪製第一個圓（填充顏色和邊框顏色）\nctx.beginPath()\nctx.arc(x1, y1, radius, 0, 2 * 3.14159)\nctx.fillStyle = "lightyellow"  # 第一個圓的填充顏色\nctx.fill()\nctx.lineWidth = 2\nctx.strokeStyle = "black"  # 第一個圓的邊框顏色\nctx.stroke()\n\n# 繪製第二個圓（填充顏色和邊框顏色）\nctx.beginPath()\nctx.arc(x2, y2, radius, 0, 2 * 3.14159)\nctx.fillStyle = "mediumseagreen"  # 第二個圓的填充顏色\nctx.fill()\nctx.lineWidth = 2\nctx.strokeStyle = "black"  # 第二個圓的邊框顏色\nctx.stroke()\n\n# 填充兩個圓的交集區域\nctx.save()\nctx.beginPath()\nctx.arc(x1, y1, radius, 0, 2 * 3.14159)\nctx.clip()  # 設置剪裁區域為第一個圓\nctx.beginPath()\nctx.arc(x2, y2, radius, 0, 2 * 3.14159)\nctx.fillStyle = "skyblue"  # 交集區域的顏色\nctx.fill()\nctx.restore()\n\n# 繪製第一個正方形（紅色邊框，紫色填充）\nctx.beginPath()\nctx.rect(100, 100, 200, 200)\nctx.fillStyle = "purple"  # 第一個正方形的填充顏色\nctx.fill()\nctx.lineWidth = 2\nctx.strokeStyle = "red"  # 第一個正方形的邊框顏色\nctx.stroke()\n\n# 繪製第二個正方形（紅色邊框，粉紅色填充）\nctx.beginPath()\nctx.rect(200, 200, 200, 200)\nctx.fillStyle = "pink"  # 第二個正方形的填充顏色\nctx.fill()\nctx.stroke()\n\n# 繪製圓形邊框（黑色邊框）\nctx.beginPath()\nctx.arc(x1, y1, radius, 0, 2 * 3.14159)\nctx.lineWidth = 3  # 設置圓形邊框的寬度\nctx.strokeStyle = "black"  # 第一個圓的邊框顏色\nctx.stroke()\n\nctx.beginPath()\nctx.arc(x2, y2, radius, 0, 2 * 3.14159)\nctx.lineWidth = 3  # 設置圓形邊框的寬度\nctx.strokeStyle = "black"  # 第二個圓的邊框顏色\nctx.stroke()\n\n# 現在繪製對角線，並分開處理\nctx.beginPath()\nctx.moveTo(100, 100)\nctx.lineTo(300, 300)\nctx.strokeStyle = "blue"  # 對角線顏色\nctx.lineWidth = 2  # 設置對角線的寬度\nctx.stroke()\n \n \n \n \n \n', 'tags': '', 'url': 'w13_hw.html'}, {'title': 'w14_ex', 'text': '請根據兩個圓繪圖所圍成的區域(目前圍成三個區域, 但若圓心移動可能彼此獨立)進行不同顏色著色, 條件是當各圓半徑與圓心座標變動時, 程式只需輸入兩個圓的圓心座標與半徑, 就可以完成各區域的著色任務. \n 修改為 三個圓的區域塗色任務 \n from browser import html\nfrom browser import document as doc\nimport random\nimport math\n\n# 定義一個函式來初始化畫布\ndef initialize_canvas(canvas_width=400, canvas_height=400, id="brython_div1"):\n    """\n    初始化畫布，創建一個指定大小的 Canvas 元素，並將其加到 HTML 文件中。\n    返回畫布元素和它的 2D 繪圖上下文。\n    """\n    # 創建畫布元素並設置大小\n    canvas = html.CANVAS(width=canvas_width, height=canvas_height)\n    # 獲取指定 id 的 div 元素，並將畫布添加進去\n    brython_div = doc[id]\n    brython_div <= canvas\n\n    # 返回 2D 繪圖上下文\n    ctx = canvas.getContext("2d")\n    return canvas, ctx\n\n# 定義一個隨機顏色生成函式\ndef random_color_generator():\n    """\n    生成一個隨機的 RGB 顏色字符串。\n    返回的顏色是 "rgb(r, g, b)" 格式，其中 r, g, b 是 0 到 255 之間的隨機整數。\n    """\n    # 隨機生成 RGB 三個分量\n    r = random.randint(0, 255)\n    g = random.randint(0, 255)\n    b = random.randint(0, 255)\n    return f"rgb({r}, {g}, {b})"\n\n# 判斷點 (px, py) 是否在圓內\ndef is_point_in_circle(px, py, cx, cy, r):\n    """\n    判斷一個點是否位於指定圓內。\n    px, py: 點的座標\n    cx, cy: 圓心座標\n    r: 圓的半徑\n    """\n    return (px - cx) ** 2 + (py - cy) ** 2 <= r ** 2\n\n# 三個圓的區域塗色函式\ndef draw_circles(x1, y1, r1, x2, y2, r2, x3, y3, r3):\n    """\n    繪製三個圓及其交集區域，使用不同顏色區分。\n    x1, y1, r1: 第一個圓的圓心和半徑\n    x2, y2, r2: 第二個圓的圓心和半徑\n    x3, y3, r3: 第三個圓的圓心和半徑\n    """\n    # 初始化畫布\n    canvas, ctx = initialize_canvas(400, 400)\n    # 清空畫布\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    # 用於存儲不同區域顏色的字典\n    color_dict = {}\n\n    # 逐行掃描每個像素\n    for py in range(0, canvas.height):\n        for px in range(0, canvas.width):\n            # 判斷該點是否在每個圓內\n            in_circle1 = is_point_in_circle(px, py, x1, y1, r1)\n            in_circle2 = is_point_in_circle(px, py, x2, y2, r2)\n            in_circle3 = is_point_in_circle(px, py, x3, y3, r3)\n\n            # 根據點的狀態選擇顏色\n            if in_circle1 and in_circle2 and in_circle3:\n                if "intersection_all" not in color_dict:\n                    color_dict["intersection_all"] = random_color_generator()\n                current_color = color_dict["intersection_all"]\n            elif in_circle1 and in_circle2:\n                if "intersection_12" not in color_dict:\n                    color_dict["intersection_12"] = random_color_generator()\n                current_color = color_dict["intersection_12"]\n            elif in_circle1 and in_circle3:\n                if "intersection_13" not in color_dict:\n                    color_dict["intersection_13"] = random_color_generator()\n                current_color = color_dict["intersection_13"]\n            elif in_circle2 and in_circle3:\n                if "intersection_23" not in color_dict:\n                    color_dict["intersection_23"] = random_color_generator()\n                current_color = color_dict["intersection_23"]\n            elif in_circle1:\n                if "circle1" not in color_dict:\n                    color_dict["circle1"] = random_color_generator()\n                current_color = color_dict["circle1"]\n            elif in_circle2:\n                if "circle2" not in color_dict:\n                    color_dict["circle2"] = random_color_generator()\n                current_color = color_dict["circle2"]\n            elif in_circle3:\n                if "circle3" not in color_dict:\n                    color_dict["circle3"] = random_color_generator()\n                current_color = color_dict["circle3"]\n            else:\n                current_color = "white"\n\n            # 塗色當前像素\n            ctx.fillStyle = current_color\n            ctx.fillRect(px, py, 1, 1)\n\n# 從使用者輸入獲取三個圓的圓心和半徑\ndef get_circle_input():\n    """\n    提示使用者輸入三個圓的圓心座標和半徑。\n    返回三個圓的參數。\n    """\n    print("請輸入三個圓的圓心座標和半徑：")\n    x1, y1, r1 = map(int, input("輸入圓1 (x y r)：").split())\n    x2, y2, r2 = map(int, input("輸入圓2 (x y r)：").split())\n    x3, y3, r3 = map(int, input("輸入圓3 (x y r)：").split())\n    return x1, y1, r1, x2, y2, r2, x3, y3, r3\n\n# 主程式開始，從使用者輸入獲取圓的參數，並進行繪製\nx1, y1, r1, x2, y2, r2, x3, y3, r3 = get_circle_input()\ndraw_circles(x1, y1, r1, x2, y2, r2, x3, y3, r3)\n \n \n', 'tags': '', 'url': 'w14_ex.html'}, {'title': 'w15', 'text': '題目一: 請利用 Gist 與 Brython 程式環境, 在個人的課程網站中新增一個頁面, 標題為 w15, 以" 從 1 累加到 100 "作為 anchor 的連結標題, 使用者點擊該連結之後, 可從各自的 Brython 頁面執行程式. \n # 初始化變數 sum 為 0，用來儲存累加的結果\nsum = 0\n\n# 使用 for 迴圈，從 0 到 100（包含 100）逐一遍歷\n# range(0, 101) 代表數字序列從 0 到 100\nfor i in range(0, 101):\n    # 將目前的數字 i 累加到 sum\n    sum += i\n\n# 將累加結果輸出到畫面\nprint(sum) \n 題目二: 延伸上題, 設計一個函式  addto (1, 100), 可以完成上述的累加結果.\xa0 \n def addto(start, end):\n    """\n    計算從 start 到 end 之間所有整數的總和。\n    \n    參數：\n    start: 開始的整數\n    end: 結束的整數（包含在內）\n\n    返回：\n    整數總和\n    """\n    sum = 0  # 初始化總和為 0\n    for i in range(start, end + 1):  # 從 start 累加到 end，包含 end\n        sum += i  # 將當前數字加入總和\n    return sum  # 返回計算的總和\n\n# 測試函式\nresult = addto(1, 100)  # 計算 1 到 100 的總和\nprint(result)  # 輸出結果 \n 題目三: 延伸上題, 設計一個函式  add_only_even (1, 100), 可以完成從第一個輸入整數, 累加到第二個輸入變數的累加結果, 但只納入偶數. 頁面中請以\xa0add_only_even 作為連結標題. \n def add_only_even(start, end):\n    # 初始化變數 sum 為 0，用來儲存偶數的累加結果\n    sum = 0\n    \n    # 使用 for 迴圈，從 start 到 end（包含 end），逐一遍歷\n    for i in range(start, end + 1):\n        # 檢查 i 是否為偶數\n        if i % 1 == 0:\n            # 如果是偶數，就將其加到 sum\n            sum += i\n            # 輸出目前的累加結果\n            print(f"{sum}")\n\n# 範例：從 1 到 100 累加偶數\nadd_only_even(1, 100)\n \n 題目四: 延伸上題, 設計一個函式  add_avoid_8 (1, 100), 可以完成從第一個輸入整數, 累加到第二個輸入變數的累加過程, 必須避開數字出現"8"的整數 \n def add_avoid_8(start, end):\n    # 初始化變數 sum 為 0，用來儲存累加結果\n    sum = 0\n    \n    # 使用 for 迴圈，從 start 到 end（包含 end），逐一遍歷\n    for i in range(start, end + 1):\n        # 檢查 i 是否包含數字 \'8\'\n        if \'8\' not in str(i):  # 將 i 轉為字串來檢查是否包含 \'8\'\n            # 如果不包含 \'8\'，就將其加到 sum\n            sum += i\n            # 輸出目前的累加結果\n            print(f" {sum}")\n    \n    # 返回累加結果\n    return sum\n\n# 範例：從 1 到 100 累加不包含 \'8\' 的整數\nresult = add_avoid_8(1, 100)\nprint(f"")\n \n \n 上課延伸: 3092 \n 這些函式展示了 Python 的基礎控制結構（ for  迴圈、條件判斷）、數學運算（加法、取餘運算）、字串操作（轉型與檢查）以及函式的封裝能力 \n', 'tags': '', 'url': 'w15.html'}, {'title': 'HW 2', 'text': '主題: Python 的數列、判斷式與重複迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 2 and Part 3 \n \n 延續 HW 1 網頁資料整理與程式練習方法, 整理下列內容 (20%): \n PART 2: Introduction to lists and if/else statements \n PART 3: Introduction to the for loop \n 完成上述流程整理後, 請將 HW2 自評分數輸入 cp2024 自評表單中. \n \xa0\xa0 \n', 'tags': '', 'url': 'HW 2.html'}, {'title': 'HW 2 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 2 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 2 Exam.html'}, {'title': 'w16_exam1', 'text': '題目: 請以 自己的學號最後四碼 作為繪圖的座標原點, (例如: 若學號最後四碼為 3932, 請將 (39, 32) 作為繪圖座標原點), 並以 pixel=2 的黑色直線分別利用 Brython 繪圖, 標示出向右為正的 X 軸, 以及向下為正的 Y 軸, 並且利用文字標示出原點座標 (例如: (39, 32)), 之後請自選最左側圖形的起始點座標, 直接在頁面畫出下列圖像, 繪圖程式除了必須直接列在頁面 html 檔案外, 也請存入自己的 Gist 區域, 並在所完成的圖像下方, 以自選標題的 anchor 連結至 Gist, 讓使用者點擊該連結後, 可以在各自的 Brython 頁面中繪出下列圖像 ( 圖片來源 ). \n 解: exam1 \n from browser import html\nfrom browser import document as doc\nimport math\n\n# 初始化畫布\ndef initialize_canvas(canvas_width=1000, canvas_height=400, id="brython_div1"):\n    """\n    初始化畫布，創建一個指定大小的 Canvas 元素，並將其加到 HTML 文件中。\n    返回畫布元素和它的 2D 繪圖上下文。\n    """\n    canvas = html.CANVAS(width=canvas_width, height=canvas_height)\n    brython_div = doc[id]\n    brython_div <= canvas\n    ctx = canvas.getContext("2d")\n    return canvas, ctx\n\n# 繪製六邊形\ndef draw_hexagon(ctx, center_x, center_y, size, color):\n    """\n    繪製一個六邊形。\n    center_x, center_y: 六邊形的中心座標\n    size: 六邊形的邊長\n    color: 六邊形的顏色\n    """\n    ctx.beginPath()\n    for i in range(6):\n        angle = math.radians(60 * i)\n        x = center_x + size * math.cos(angle)\n        y = center_y + size * math.sin(angle)\n        if i == 0:\n            ctx.moveTo(x, y)\n        else:\n            ctx.lineTo(x, y)\n    ctx.closePath()\n    ctx.fillStyle = color\n    ctx.fill()\n\n# 繪製直立菱形\ndef draw_rhombus(ctx, center_x, center_y, width, height, color):\n    """\n    繪製一個直立的菱形，邊與 X 軸和 Y 軸平行。\n    center_x, center_y: 菱形的中心座標\n    width: 菱形的寬度\n    height: 菱形的高度\n    color: 菱形的顏色\n    """\n    ctx.beginPath()\n    ctx.moveTo(center_x - width / 2, center_y)  # 左頂點\n    ctx.lineTo(center_x, center_y - height / 2)  # 上頂點\n    ctx.lineTo(center_x + width / 2, center_y)  # 右頂點\n    ctx.lineTo(center_x, center_y + height / 2)  # 下頂點\n    ctx.closePath()\n    ctx.fillStyle = color\n    ctx.fill()\n\n# 繪製正三角形\ndef draw_triangle(ctx, center_x, center_y, size, color):\n    """\n    繪製一個正三角形。\n    center_x, center_y: 三角形的中心座標\n    size: 三角形的邊長\n    color: 三角形的顏色\n    """\n    height = math.sqrt(3) * size / 2  # 正三角形的高度\n    # 正三角形的頂點位置需要調整，使其對齊菱形中心\n    ctx.beginPath()\n    ctx.moveTo(center_x - size / 2, center_y + height / 2)  # 左底點\n    ctx.lineTo(center_x + size / 2, center_y + height / 2)  # 右底點\n    ctx.lineTo(center_x, center_y - height / 2)  # 上頂點\n    ctx.closePath()\n    ctx.fillStyle = color\n    ctx.fill()\n\n# 繪製圓形\ndef draw_circle(ctx, center_x, center_y, radius, color):\n    """\n    繪製一個圓形。\n    center_x, center_y: 圓形的中心座標\n    radius: 圓形的半徑\n    color: 圓形的顏色\n    """\n    ctx.beginPath()\n    ctx.arc(center_x, center_y, radius, 0, 2 * math.pi)\n    ctx.closePath()\n    ctx.fillStyle = color\n    ctx.fill()\n\n# 繪製正方形\ndef draw_square(ctx, center_x, center_y, size, color):\n    """\n    繪製一個正方形。\n    center_x, center_y: 正方形的中心座標\n    size: 正方形的邊長\n    color: 正方形的顏色\n    """\n    ctx.beginPath()\n    ctx.rect(center_x - size / 2, center_y - size / 2, size, size)\n    ctx.closePath()\n    ctx.fillStyle = color\n    ctx.fill()\n\n# 繪製長方形\ndef draw_rectangle(ctx, center_x, center_y, width, height, color):\n    """\n    繪製一個長方形。\n    center_x, center_y: 長方形的中心座標\n    width: 長方形的寬度\n    height: 長方形的高度\n    color: 長方形的顏色\n    """\n    ctx.beginPath()\n    ctx.rect(center_x - width / 2, center_y - height / 2, width, height)\n    ctx.closePath()\n    ctx.fillStyle = color\n    ctx.fill()\n\n# 繪製坐標軸和原點標註\ndef draw_axes_and_origin(ctx, origin_x, origin_y):\n    """\n    繪製坐標軸和原點標註。\n    origin_x, origin_y: 原點位置\n    """\n    # 設置顏色為黑色\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    \n    # 繪製 X 軸 (向右為正)\n    ctx.beginPath()\n    ctx.moveTo(0, origin_y)\n    ctx.lineTo(1000, origin_y)  # 延長到畫布的最右端\n    ctx.stroke()\n    \n    # 繪製 Y 軸 (向下為正)\n    ctx.beginPath()\n    ctx.moveTo(origin_x, 0)\n    ctx.lineTo(origin_x, 400)  # 延長到畫布的底端\n    ctx.stroke()\n    \n    # 標註原點 (31, 43)\n    ctx.fillStyle = "black"\n    ctx.font = "16px Arial"\n    ctx.fillText(f"原點(31, 43)", origin_x + 10, origin_y - 10)  # 原點附近顯示文字\n\n# 繪製所有圖形\ndef draw_shapes():\n    # 初始化畫布\n    canvas, ctx = initialize_canvas(1000, 400)\n\n    # 原點位置 (31, 43)\n    origin_x = 31\n    origin_y = 43\n    \n    # 先繪製坐標軸\n    draw_axes_and_origin(ctx, origin_x, origin_y)\n\n    # 圖形大小和位置參數\n    y_center = 200  # 所有圖形的 Y 軸中心位置\n    spacing = 120  # 圖形之間的間隔\n\n    # 六邊形\n    hexagon_size = 40  # 六邊形的邊長\n    draw_hexagon(ctx, 100, y_center, hexagon_size, "orange")\n\n    # 直立菱形\n    rhombus_width = 60  # 菱形的寬度 \n    rhombus_height = 80  # 菱形的高度 \n    draw_rhombus(ctx, 100 + spacing, y_center, rhombus_width, rhombus_height, "green")\n\n    # 正三角形，計算三角形的位置，使頂點與菱形中心對齊\n    triangle_size = 60  # 正三角形的邊長\n    triangle_x = 100 + spacing + rhombus_width / 2  # 三角形的 X 座標\n    triangle_y = y_center + rhombus_height / 2  # 三角形的 Y 座標 (使頂點對齊菱形的中心)\n    draw_triangle(ctx, triangle_x, triangle_y, triangle_size, "blue")\n\n    # 圓形\n    circle_radius = 40  # 圓形的半徑\n    draw_circle(ctx, 100 + 2 * spacing, y_center, circle_radius, "pink")\n\n    # 正方形\n    square_size = 60  # 正方形的邊長\n    draw_square(ctx, 100 + 3 * spacing, y_center, square_size, "yellow")\n\n    # 長方形\n    rectangle_width = 100  # 長方形的寬度\n    rectangle_height = 60  # 長方形的高度\n    draw_rectangle(ctx, 100 + 4 * spacing, y_center, rectangle_width, rectangle_height, "blue")\n\n# 主程式開始\ndraw_shapes()\n \n \n  導入 brython 程式庫  \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'w16_exam1.html'}, {'title': 'HW 3', 'text': '主題: Python 的數字、演算法與迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 4 and Part 5 \n 完成上述流程整理後, 請將 HW3 自評分數輸入 cp2024 自評表單中. \n \n', 'tags': '', 'url': 'HW 3.html'}, {'title': 'HW 3 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 3 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 3 Exam.html'}, {'title': 'w16_exam2', 'text': '題目一: 請以 自己的學號最後四碼 作為下列繪圖的左上方點座標, (例如: 若學號最後四碼為 3932, 請將 (39, 32) 作為繪圖左上方點座標), 並以紅色文字標示出該點座標 (例如: (39, 32)), 之後請利用\xa0 pixel=2 的藍色直線 ,\xa0 自訂迷宮畫布大小 , 直接在頁面畫出下列圖像, 繪圖程式除了必須直接列在頁面 html 檔案外, 也請存入自己的 Gist 區域, 並在所完成的圖像下方, 以自選標題的 anchor 連結至 Gist, 讓使用者點擊該連結後, 可以在各自的 Brython 頁面中繪出下列圖像). \n w16_exam2 \n from browser import html\nfrom browser import document as doc\n\n# 建立畫布，畫布尺寸縮小為 400x400\ncanvas = html.CANVAS(width=400, height=400)  \nbrython_div = doc["brython_div1"]  # 將畫布放置於網頁中的指定 div\nbrython_div <= canvas\n\n# 取得 canvas 的 2D 繪圖上下文 (context)，可以用來進行繪圖\nctx = canvas.getContext("2d")\n\n# 每一格的像素大小，調整為 50 (原為 100)\npixel_scale = 50  # 縮小每格的像素大小\n\n# 定義原點 (31, 14) 作為起始點偏移，並將偏移值縮小\noffset_x = 32 * 2  # 偏移量仍保留為兩倍放大 (原為 32，放大後為 64)\noffset_y = 10 * 2  # 偏移量仍保留為兩倍放大 (原為 10，放大後為 20)\n\n# 定義迷宮的線條，這裡使用的是一組二維坐標來描述迷宮的邊界\nlines = [\n    ((0, 0), (2, 0)),\n    ((3, 0), (5, 0)),\n    ((5, 0), (5, 5)),\n    ((3, 5), (5, 5)),\n    ((5, 5), (4, 5)),\n    ((4, 5), (4, 3)),\n    ((4, 3), (1, 3)),\n    ((1, 3), (1, 4)),\n    ((3, 3), (3, 2)),\n    # 第二條線\n    ((0, 0), (0, 5)),\n    ((0, 5), (2, 5)),\n    ((2, 5), (2, 4)),\n    ((2, 4), (3, 4)),\n    ((0, 2), (2, 2)),\n    ((2, 2), (2, 1)),\n    ((1, 1), (4, 1)),\n    ((4, 1), (4, 2)),\n]\n\n# 設定線條顏色為藍色\nctx.strokeStyle = "blue"\n# 設定線條寬度為 4 像素\nctx.lineWidth = 4\n\n# 繪製迷宮的每一條線\nfor line in lines:\n    start = line[0]  # 取得每條線的起點\n    end = line[1]    # 取得每條線的終點\n    ctx.beginPath()  # 開始繪製新的一條路徑\n    ctx.moveTo(\n        offset_x + start[0] * pixel_scale,  # 起點的 X 座標\n        offset_y + start[1] * pixel_scale   # 起點的 Y 座標\n    )\n    ctx.lineTo(\n        offset_x + end[0] * pixel_scale,    # 終點的 X 座標\n        offset_y + end[1] * pixel_scale     # 終點的 Y 座標\n    )\n    ctx.stroke()  # 繪製線條\n\n# 設定字體大小為 14px Arial，並將顏色設為紅色\nctx.font = "14px Arial"\nctx.fillStyle = "red"\n# 更新座標標註，顯示新的座標 (31, 43)，並將標註位置調整\nctx.fillText("(31, 43)", offset_x + 0, offset_y -10)\n \n \xa0 \n  導入 brython 程式庫  \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'w16_exam2.html'}, {'title': 'HW 4', 'text': '主題: 利用 Python 控制機電模擬系統 (20%) \n 利用\xa0 https://solvespace.com/ \xa0建立機械系統零組件 \n 利用  CoppeliaSim  建立機電模擬系統 \n 利用  Python  跨網路控制瀏覽器上的機電模擬系統 \n 範例: \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n 完成上述流程整理後, 請將 HW4 自評分數輸入 cp2024 自評表單中. \n \xa0 \xa0\xa0 \n', 'tags': '', 'url': 'HW 4.html'}, {'title': 'HW 4 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 4 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 4 Exam.html'}, {'title': 'w16_exam3', 'text': '題目一: 請以 自己的學號最後四碼 作為下列繪圖的左上方點座標, (例如: 若學號最後四碼為 3932, 請將 (39, 32) 作為繪圖左上方點座標), 並以紅色文字標示出該點座標 (例如: (39, 32)), 之後請利用\xa0 pixel=2 的黑色直線 ,\xa0 自訂迷宮畫布大小 , 直接在頁面畫出下列圖像, 並且 利用紅色連續線段標示從上方入口, 走至下方出口的路線圖 . \n w16_exam3 \n from browser import html\nfrom browser import document as doc\n\n# 建立畫布，畫布尺寸縮小為 400x400\ncanvas = html.CANVAS(width=400, height=400)  \nbrython_div = doc["brython_div1"]  # 將畫布放置於網頁中的指定 div\nbrython_div <= canvas\n\n# 取得 canvas 的 2D 繪圖上下文 (context)，可以用來進行繪圖\nctx = canvas.getContext("2d")\n\n# 每一格的像素大小，調整為 50 (原為 100)\npixel_scale = 50  # 縮小每格的像素大小\n\n# 定義原點 (31, 14) 作為起始點偏移，並將偏移值縮小\noffset_x = 32 * 2  # 偏移量仍保留為兩倍放大 (原為 32，放大後為 64)\noffset_y = 10 * 2  # 偏移量仍保留為兩倍放大 (原為 10，放大後為 20)\n\n# 定義迷宮的線條，這裡使用的是一組二維坐標來描述迷宮的邊界\nlines = [\n    ((0, 0), (2, 0)),\n    ((3, 0), (5, 0)),\n    ((5, 0), (5, 5)),\n    ((3, 5), (5, 5)),\n    ((5, 5), (4, 5)),\n    ((4, 5), (4, 3)),\n    ((4, 3), (1, 3)),\n    ((1, 3), (1, 4)),\n    ((3, 3), (3, 2)),\n    # 第二條線\n    ((0, 0), (0, 5)),\n    ((0, 5), (2, 5)),\n    ((2, 5), (2, 4)),\n    ((2, 4), (3, 4)),\n    ((0, 2), (2, 2)),\n    ((2, 2), (2, 1)),\n    ((1, 1), (4, 1)),\n    ((4, 1), (4, 2)),\n]\n\n# 設定線條顏色為藍色\nctx.strokeStyle = "black"\n# 設定線條寬度為 4 像素\nctx.lineWidth = 4\n\n# 繪製迷宮的每一條線\nfor line in lines:\n    start = line[0]  # 取得每條線的起點\n    end = line[1]    # 取得每條線的終點\n    ctx.beginPath()  # 開始繪製新的一條路徑\n    ctx.moveTo(\n        offset_x + start[0] * pixel_scale,  # 起點的 X 座標\n        offset_y + start[1] * pixel_scale   # 起點的 Y 座標\n    )\n    ctx.lineTo(\n        offset_x + end[0] * pixel_scale,    # 終點的 X 座標\n        offset_y + end[1] * pixel_scale     # 終點的 Y 座標\n    )\n    ctx.stroke()  # 繪製線條\n\n# 定義迷宮的解答路徑\npath = [\n    (2.5, 0),  # 入口\n    (2.5, 0.5),\n    (4.5, 0.5),\n    (4.5, 2.5),\n    (3.5, 2.5),\n    (3.5, 1.5),\n    (2.5, 1.5),\n    (2.5, 2.5),\n    (0.5, 2.5),\n    (0.5, 4.5),\n    (1.5, 4.5),\n    (1.5, 3.5),\n    (3.5, 3.5),\n    (3.5, 4.5),\n    (2.5, 4.5),\n    (2.5, 5),  # 出口\n]\n\n# 設定線條顏色為紅色，表示路徑\nctx.strokeStyle = "red"\nctx.lineWidth = 4\n\n# 繪製解答路徑的每一條線\nfor i in range(len(path) - 1):\n    start = path[i]   # 取得每條路徑的起點\n    end = path[i + 1]  # 取得每條路徑的終點\n    ctx.beginPath()\n    ctx.moveTo(\n        offset_x + start[0] * pixel_scale,  # 起點的 X 座標\n        offset_y + start[1] * pixel_scale   # 起點的 Y 座標\n    )\n    ctx.lineTo(\n        offset_x + end[0] * pixel_scale,    # 終點的 X 座標\n        offset_y + end[1] * pixel_scale     # 終點的 Y 座標\n    )\n    ctx.stroke()  # 繪製線條\n\n# 設定字體大小為 14px Arial，並將顏色設為紅色\nctx.font = "14px Arial"\nctx.fillStyle = "red"\n# 更新座標標註，顯示新的座標 (31, 43)，並將標註位置調整\nctx.fillText("(31, 43)", offset_x + 0, offset_y -10)\n \n  導入 brython 程式庫  \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'w16_exam3.html'}, {'title': 'Final Report', 'text': '期末口頭與書面專題報告 (20%) \n \n 期末口頭專題報告影片: \n \n 期末書面專題報告檔案 (pdf): \n \n 電腦輔助設計與實習課程總結心得: \n 這堂課老師教了很多的程式，學習到很多的用法，有些作業雖然做很久，但還是有做出來，有些部分做久了都熟悉了 \n 期末報告自評成績: \n 完成上述流程後, 請將 Final Report 自評分數輸入 cp2024 自評表單中.', 'tags': '', 'url': 'Final Report.html'}, {'title': '簡單的數學計算器', 'text': '\xa0\xa0 \n \n 寫一個函數 `calculate`，接受三個參數：操作（加、減、乘、除）和兩個數字。根據操作進行對應的計算並返回結果。 \n \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n \n \n \n def   calculate(operation, num1, num2):\xa0  # 定義函數 calculate，接受三個參數：操作符、第一個數字和第二個數字 \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 根據指定的操作符對兩個數字進行計算並返回結果。 \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 if   operation  = =   "加" :\xa0  # 檢查操作符是否為 "加" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   num1  +   num2\xa0  # 返回兩個數字的加法結果 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "減" :\xa0  # 檢查操作符是否為 "減" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   num1  -   num2\xa0  # 返回兩個數字的減法結果 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "乘" :\xa0  # 檢查操作符是否為 "乘" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   num1  *   num2\xa0  # 返回兩個數字的乘法結果 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "除" :\xa0  # 檢查操作符是否為 "除" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   num2 ! =   0 :\xa0  # 確保第二個數字不是零，避免除以零的錯誤 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   num1  /   num2\xa0  # 返回兩個數字的除法結果 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else :\xa0  # 如果第二個數字是零 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：不能除以零！" \xa0  # 返回錯誤訊息 \n \xa0\xa0\xa0\xa0 else :\xa0  # 如果操作符不是加、減、乘或除 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：無效的操作！" \xa0  # 返回錯誤訊息 \n print (calculate( "加" ,  10 ,  5 )) \n \n \n \n \n \n \n \n \n 寫一個函數 `advanced_calculate`，接受四個參數：操作（加、減、乘、除、次方、取餘數）和兩個數字，以及一個布林值參數，表示是否要返回計算步驟的詳細過程。根據操作進行對應的計算並返回結果和計算步驟（若布林值為真）。\n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n \n \n \n def   advanced_calculate(operation, num1, num2, show_steps):\xa0  \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 根據指定的操作對兩個數字進行計算，並根據布林值決定是否返回計算步驟。 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 參數： \n \xa0\xa0\xa0\xa0 - operation: 字符串，指定操作類型（加、減、乘、除、次方、取餘數） \n \xa0\xa0\xa0\xa0 - num1: 第一個數字 \n \xa0\xa0\xa0\xa0 - num2: 第二個數字 \n \xa0\xa0\xa0\xa0 - show_steps: 布林值，若為 True，則返回計算步驟 \n \xa0 \n \xa0\xa0\xa0\xa0 返回： \n \xa0\xa0\xa0\xa0 - 若 show_steps 為 False，僅返回計算結果 \n \xa0\xa0\xa0\xa0 - 若 show_steps 為 True，返回計算結果和步驟描述 \n \xa0 \n \xa0\xa0\xa0\xa0 測試範例： \n \xa0\xa0\xa0\xa0 # 測試加法並顯示計算步驟 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("加", 10, 5, True))\xa0 # 輸出 (15, "10 + 5 = 15") \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試減法並不顯示計算步驟 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("減", 10, 5, False))\xa0 # 輸出 5 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試乘法並顯示計算步驟 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("乘", 10, 5, True))\xa0 # 輸出 (50, "10 * 5 = 50") \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試除法並顯示計算步驟 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("除", 10, 5, True))\xa0 # 輸出 (2.0, "10 / 5 = 2.0") \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試次方 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("次方", 2, 3, True))\xa0 # 輸出 (8, "2 ^ 3 = 8") \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試取餘數 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("取餘數", 10, 3, True))\xa0 # 輸出 (1, "10 % 3 = 1") \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試無效操作符 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("平方根", 10, 5, True))\xa0 # 輸出 "錯誤：無效的操作！" \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試除以零 \n \xa0\xa0\xa0\xa0 print(advanced_calculate("除", 10, 0, True))\xa0 # 輸出 "錯誤：不能除以零！" \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 steps  =   ""\xa0  # 初始化用於存儲步驟的變數 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 if   operation  = =   "加" :\xa0  # 檢查是否執行加法 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   num1  +   num2\xa0  # 計算加法結果 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steps  =   f "{num1} + {num2} = {result}" \xa0  # 記錄加法步驟 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "減" :\xa0  # 檢查是否執行減法 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   num1  -   num2\xa0  # 計算減法結果 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steps  =   f "{num1} - {num2} = {result}" \xa0  # 記錄減法步驟 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "乘" :\xa0  # 檢查是否執行乘法 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   num1  *   num2\xa0  # 計算乘法結果 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steps  =   f "{num1} * {num2} = {result}" \xa0  # 記錄乘法步驟 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "除" :\xa0  # 檢查是否執行除法 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   num2 ! =   0 :\xa0  # 確保除數不為零 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   num1  /   num2\xa0  # 計算除法結果 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steps  =   f "{num1} / {num2} = {result}" \xa0  # 記錄除法步驟 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：不能除以零！" \xa0  # 返回錯誤訊息 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "次方" :\xa0  # 檢查是否執行次方 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   num1  * *   num2\xa0  # 計算次方結果 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steps  =   f "{num1} ^ {num2} = {result}" \xa0  # 記錄次方步驟 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "取餘數" :\xa0  # 檢查是否執行取餘數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   num1  %   num2\xa0  # 計算餘數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steps  =   f "{num1} % {num2} = {result}" \xa0  # 記錄取餘數步驟 \n \xa0\xa0\xa0\xa0 else :\xa0  # 無效操作符的情況 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：無效的操作！" \xa0  # 返回錯誤訊息 \n \xa0 \n \xa0\xa0\xa0\xa0 # 根據 show_steps 決定返回結果 \n \xa0\xa0\xa0\xa0 if   show_steps:\xa0  # 如果需要顯示計算步驟 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   result, steps\xa0  # 返回結果和步驟 \n \xa0\xa0\xa0\xa0 else :\xa0  # 如果不需要顯示計算步驟 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   result\xa0  # 僅返回結果 \n \n \n \n \n \n \n \n \n \n \n \n 寫一個函數 `unit_converter`，接受三個參數：轉換類型（例如：米-公里、克-千克、華氏-攝氏）和兩個數字（值與小數點後的位數）。根據轉換類型進行對應的單位轉換並返回結果。\n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n \n \n \n def unit_converter(conversion_type, value, decimal_places):\xa0  \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 根據指定的轉換類型對值進行單位轉換，並根據指定的小數點位數返回結果。 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 參數： \n \xa0\xa0\xa0\xa0 - conversion_type: 字符串，轉換類型（例如：米-公里、克-千克、華氏-攝氏） \n \xa0\xa0\xa0\xa0 - value: 數值，需要轉換的數字 \n \xa0\xa0\xa0\xa0 - decimal_places: 整數，小數點後保留的位數 \n \xa0 \n \xa0\xa0\xa0\xa0 返回： \n \xa0\xa0\xa0\xa0 - 轉換結果，保留指定的小數點位數 \n \xa0 \n \xa0\xa0\xa0\xa0 測試範例： \n \xa0\xa0\xa0\xa0 # 測試米到公里 \n \xa0\xa0\xa0\xa0 print(unit_converter("米-公里", 1500, 2))\xa0 # 輸出 1.50 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試克到千克 \n \xa0\xa0\xa0\xa0 print(unit_converter("克-千克", 500, 3))\xa0 # 輸出 0.500 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試華氏到攝氏 \n \xa0\xa0\xa0\xa0 print(unit_converter("華氏-攝氏", 98.6, 1))\xa0 # 輸出 37.0 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試無效轉換類型 \n \xa0\xa0\xa0\xa0 print(unit_converter("公里-米", 1, 2))\xa0 # 輸出 "錯誤：無效的轉換類型！" \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 if conversion_type == "米-公里":\xa0 # 檢查是否進行米到公里的轉換 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result = value / 1000\xa0 # 將數值從米轉換為公里 \n \xa0\xa0\xa0\xa0 elif conversion_type == "克-千克":\xa0 # 檢查是否進行克到千克的轉換 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result = value / 1000\xa0 # 將數值從克轉換為千克 \n \xa0\xa0\xa0\xa0 elif conversion_type == "華氏-攝氏":\xa0 # 檢查是否進行華氏到攝氏的轉換 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result = (value - 32) * 5 / 9\xa0 # 使用公式將華氏轉換為攝氏 \n \xa0\xa0\xa0\xa0 else:\xa0 # 如果轉換類型無效 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return "錯誤：無效的轉換類型！"\xa0 # 返回錯誤訊息 \n \xa0 \n \xa0\xa0\xa0\xa0 # 返回結果，保留指定的小數點位數 \n \xa0\xa0\xa0\xa0 return round(result, decimal_places)\xa0 # 使用 round() 函數保留指定的小數點位數 \n \n \n \n \n \n \n \n \n \n \n \n 寫一個函數 `math_quiz`，隨機生成一個數學問題（加、減、乘、除），並接受使用者的答案。檢查答案是否正確，並返回 "正確" 或 "錯誤"。\n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n \n \n \n import   random\xa0  # 引入隨機模組，用於生成隨機數和隨機操作 \n \xa0 \n def   math_quiz(): \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 隨機生成一個數學問題（加、減、乘、除），並接受使用者的答案。 \n \xa0\xa0\xa0\xa0 檢查答案是否正確，並返回 "正確" 或 "錯誤"。 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 返回： \n \xa0\xa0\xa0\xa0 - "正確"：若使用者答案正確 \n \xa0\xa0\xa0\xa0 - "錯誤"：若使用者答案錯誤 \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 # 定義可用的操作類型 \n \xa0\xa0\xa0\xa0 operations  =   [ "+" ,  "-" ,  "*" ,  "/" ] \n \xa0\xa0\xa0\xa0 # 隨機選擇一個操作 \n \xa0\xa0\xa0\xa0 operation  =   random.choice(operations) \n \xa0\xa0\xa0\xa0 # 隨機生成兩個數字 \n \xa0\xa0\xa0\xa0 num1  =   random.randint( 1 ,  100 ) \n \xa0\xa0\xa0\xa0 num2  =   random.randint( 1 ,  100 ) \n \xa0 \n \xa0\xa0\xa0\xa0 # 確保除法時除數不為零，並保證整數結果 \n \xa0\xa0\xa0\xa0 if   operation  = =   "/" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 num1  =   num1  *   num2\xa0  # 保證結果為整數，避免小數問題 \n \xa0 \n \xa0\xa0\xa0\xa0 # 根據操作計算正確答案 \n \xa0\xa0\xa0\xa0 if   operation  = =   "+" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 correct_answer  =   num1  +   num2 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "-" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 correct_answer  =   num1  -   num2 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "*" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 correct_answer  =   num1  *   num2 \n \xa0\xa0\xa0\xa0 elif   operation  = =   "/" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 correct_answer  =   num1  / /   num2\xa0  # 整數除法 \n \xa0 \n \xa0\xa0\xa0\xa0 # 顯示問題給使用者 \n \xa0\xa0\xa0\xa0 print (f "問題：{num1} {operation} {num2} = ?" ) \n \xa0 \n \xa0\xa0\xa0\xa0 # 接受使用者輸入的答案 \n \xa0\xa0\xa0\xa0 try : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 user_answer  =   int ( input ( "請輸入你的答案：" ))\xa0  # 將輸入轉換為整數 \n \xa0\xa0\xa0\xa0 except   ValueError: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：請輸入有效的數字！" \xa0  # 如果輸入無效，提示錯誤 \n \xa0 \n \xa0\xa0\xa0\xa0 # 比較使用者答案與正確答案 \n \xa0\xa0\xa0\xa0 if   user_answer  = =   correct_answer: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "正確" \n \xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤" \n \xa0 \n # 測試範例 \n if   __name__  = =   "__main__" : \n \xa0\xa0\xa0\xa0 # 多次執行測試以檢查功能 \n \xa0\xa0\xa0\xa0 print (math_quiz())\xa0  # 問題將隨機生成，結果根據答案顯示 "正確" 或 "錯誤" \n \n \n \n \n \n \n \n \n \n \n \n 寫一個函數 `basic_statistics`，接受一個包含數字的清單，並返回該清單的平均數、中位數和標準差。\n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n \n \n \n import   statistics\xa0  # 引入 statistics 模組，用於計算中位數和標準差 \n \xa0 \n def   basic_statistics(numbers): \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 計算一個包含數字的清單的基本統計量：平均數、中位數和標準差。 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 參數： \n \xa0\xa0\xa0\xa0 - numbers: 一個包含數字的清單 \n \xa0 \n \xa0\xa0\xa0\xa0 返回： \n \xa0\xa0\xa0\xa0 - 一個字典，包含平均數（mean）、中位數（median）和標準差（std_dev） \n \xa0 \n \xa0\xa0\xa0\xa0 測試範例： \n \xa0\xa0\xa0\xa0 # 測試清單 [10, 20, 30, 40, 50] \n \xa0\xa0\xa0\xa0 print(basic_statistics([10, 20, 30, 40, 50]))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 {\'mean\': 30.0, \'median\': 30, \'std_dev\': 15.811388300841896} \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 if   not   numbers:\xa0  # 檢查清單是否為空 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：清單不能為空！" \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # 計算平均數 \n \xa0\xa0\xa0\xa0 mean  =   sum (numbers)  /   len (numbers)\xa0  # 使用 sum() 和 len() 計算平均數 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # 計算中位數 \n \xa0\xa0\xa0\xa0 median  =   statistics.median(numbers)\xa0  # 使用 statistics.median() 計算中位數 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # 計算標準差 \n \xa0\xa0\xa0\xa0 std_dev  =   statistics.stdev(numbers)  if   len (numbers) >  1   else   0 \xa0  # 保證至少有兩個數字才計算標準差 \n \xa0 \n \xa0\xa0\xa0\xa0 # 將結果組成字典返回 \n \xa0\xa0\xa0\xa0 return   { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 "mean" : mean,\xa0\xa0\xa0\xa0\xa0\xa0  # 平均數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 "median" : median,\xa0\xa0  # 中位數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 "std_dev" : std_dev\xa0  # 標準差 \n \xa0\xa0\xa0\xa0 } \n \xa0 \n # 測試範例 \n if   __name__  = =   "__main__" : \n \xa0\xa0\xa0\xa0 # 測試非空清單 \n \xa0\xa0\xa0\xa0 print (basic_statistics([ 10 ,  20 ,  30 ,  40 ,  50 ]))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 {\'mean\': 30.0, \'median\': 30, \'std_dev\': 15.811388300841896} \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試單一元素清單 \n \xa0\xa0\xa0\xa0 print (basic_statistics([ 100 ]))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 {\'mean\': 100.0, \'median\': 100, \'std_dev\': 0} \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試空清單 \n \xa0\xa0\xa0\xa0 print (basic_statistics([]))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 "錯誤：清單不能為空！" \n \n \n \n \n \n \n \n \n \n \n \n 寫一個函數 `geometry_calculator`，接受三個參數：形狀類型（例如：圓形、矩形、三角形）和兩個數字（對應的長度或寬度等）。根據形狀類型計算並返回面積。\n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n \n \n \n import   math\xa0  # 引入 math 模組，用於處理圓形的計算 \n \xa0 \n def   geometry_calculator(shape, num1, num2 = 0 ): \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 根據形狀類型計算面積。 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 參數： \n \xa0\xa0\xa0\xa0 - shape: 字符串，表示形狀類型（"圓形", "矩形", "三角形"） \n \xa0\xa0\xa0\xa0 - num1: 第一個數字（例如半徑、長度或底邊） \n \xa0\xa0\xa0\xa0 - num2: 第二個數字（例如高度或寬度，圓形可忽略） \n \xa0 \n \xa0\xa0\xa0\xa0 返回： \n \xa0\xa0\xa0\xa0 - 該形狀的面積（浮點數） \n \xa0\xa0\xa0\xa0 - 或錯誤提示字串，若形狀類型無效或參數不正確 \n \xa0 \n \xa0\xa0\xa0\xa0 測試範例： \n \xa0\xa0\xa0\xa0 # 測試圓形 \n \xa0\xa0\xa0\xa0 print(geometry_calculator("圓形", 5))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 78.53981633974483 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試矩形 \n \xa0\xa0\xa0\xa0 print(geometry_calculator("矩形", 4, 5))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 20.0 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試三角形 \n \xa0\xa0\xa0\xa0 print(geometry_calculator("三角形", 6, 8))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 24.0 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試無效形狀 \n \xa0\xa0\xa0\xa0 print(geometry_calculator("五邊形", 3, 4))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 "錯誤：不支持的形狀類型！" \n \xa0\xa0\xa0\xa0 """ \n \xa0\xa0\xa0\xa0 # 根據形狀類型進行計算 \n \xa0\xa0\xa0\xa0 if   shape  = =   "圓形" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   num1 < =   0 :\xa0  # 確保半徑有效 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：圓形的半徑必須大於 0！" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   math.pi  *   num1  * *   2 \xa0  # 計算圓的面積公式：πr^2 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 elif   shape  = =   "矩形" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   num1 < =   0   or   num2 < =   0 :\xa0  # 確保長寬有效 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：矩形的長和寬必須大於 0！" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   num1  *   num2\xa0  # 計算矩形的面積公式：長 × 寬 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 elif   shape  = =   "三角形" : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   num1 < =   0   or   num2 < =   0 :\xa0  # 確保底邊和高度有效 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：三角形的底和高必須大於 0！" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   0.5   *   num1  *   num2\xa0  # 計算三角形的面積公式：0.5 × 底 × 高 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   "錯誤：不支持的形狀類型！" \xa0  # 若形狀類型無效，返回錯誤訊息 \n \xa0 \n # 測試範例 \n if   __name__  = =   "__main__" : \n \xa0\xa0\xa0\xa0 # 測試圓形 \n \xa0\xa0\xa0\xa0 print (geometry_calculator( "圓形" ,  5 ))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 78.53981633974483 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試矩形 \n \xa0\xa0\xa0\xa0 print (geometry_calculator( "矩形" ,  4 ,  5 ))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 20.0 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試三角形 \n \xa0\xa0\xa0\xa0 print (geometry_calculator( "三角形" ,  6 ,  8 ))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 24.0 \n \xa0 \n \xa0\xa0\xa0\xa0 # 測試無效形狀 \n \xa0\xa0\xa0\xa0 print (geometry_calculator( "五邊形" ,  3 ,  4 ))\xa0  \n \xa0\xa0\xa0\xa0 # 輸出 "錯誤：不支持的形狀類型！" \n \n \n \n \n \n', 'tags': '', 'url': '簡單的數學計算器.html'}, {'title': '反轉字串', 'text': '寫一個函數 `reverse_string`，接受一個字串作為參數，並返回該字串的反轉版本。例如：`reverse_string("hello")` 應返回 `olleh`。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n \n \n \n def   reverse_string(s): \n \xa0\xa0\xa0\xa0 return   s[:: - 1 ]\xa0  # 使用切片方法反轉字串 \n \xa0 \n # 測試函數 \n print (reverse_string( "hello" ))\xa0  # 輸出: olleh \n \n \n \n \n \n \n \n 寫一個函數 string_length，接受一個字串作為參數，並返回該字串的長度。例如：string_length("hello") 應返回 5。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n \n \n \n def   string_length(s): \n \xa0\xa0\xa0\xa0 return   len (s)\xa0  # 使用內建的 len() 函數來計算字串的長度 \n \xa0 \n # 測試函數 \n print (string_length( "hello" ))\xa0  # 輸出: 5 \n \n \n \n \n \n \n \n 寫一個函數 toggle_case，接受一個字串作為參數，並返回該字串中每個字母大小寫互換後的版本。例如：toggle_case("Hello") 應返回 hELLO。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n \n \n \n def   toggle_case(s): \n \xa0\xa0\xa0\xa0 return   s.swapcase()\xa0  # 使用內建的 swapcase() 函數來互換字母的大小寫 \n \xa0 \n # 測試函數 \n print (toggle_case( "Hello" ))\xa0  # 輸出: hELLO \n \n \n \n \n \n \n \n 寫一個函數 word_count，接受一個字串作為參數，並返回該字串中單詞的數量。例如：word_count("Hello world") 應返回 2。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n \n \n \n def   word_count(s): \n \xa0\xa0\xa0\xa0 words  =   s.split()\xa0  # 使用 split() 函數將字串分割為單詞 \n \xa0\xa0\xa0\xa0 return   len (words)\xa0  # 返回單詞的數量 \n \xa0 \n # 測試函數 \n print (word_count( "Hello world" ))\xa0  # 輸出: 2 \n \n \n \n \n \n \n \n 寫一個函數 is_palindrome，接受一個字串作為參數，並返回該字串是否為迴文（正反讀都相同）。例如：is_palindrome("madam") 應返回 True。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n \n \n \n def   is_palindrome(s): \n \xa0\xa0\xa0\xa0 return   s  = =   s[:: - 1 ]\xa0  # 檢查字串是否等於它的反轉版本 \n \xa0 \n # 測試函數 \n print (is_palindrome( "madam" ))\xa0  # 輸出: True \n print (is_palindrome( "hello" ))\xa0  # 輸出: False \n \n \n \n \n \n \n \n 寫一個函數 split_string，接受一個字串和一個分隔符作為參數，並返回一個包含切割後子字串的清單。例如：split_string("hello world", " ") 應返回 [\'hello\', \'world\']。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n \n \n \n def   split_string(s, delimiter): \n \xa0\xa0\xa0\xa0 return   s.split(delimiter)\xa0  # 使用 split() 函數根據分隔符切割字串 \n \xa0 \n # 測試函數 \n print (split_string( "hello world" ,  " " ))\xa0  # 輸出: [\'hello\', \'world\'] \n \n \n \n \n \n', 'tags': '', 'url': '反轉字串.html'}, {'title': '費氏數列', 'text': '寫一個函數 `fibonacci`，接受一個整數 `n`，並返回長度為 `n` 的費氏數列。例如：`fibonacci(5)` 應返回 `[0, 1, 1, 2, 3]`。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n \n \n \n def   fibonacci(n): \n \xa0\xa0\xa0\xa0 # 初始化費氏數列，前兩個數字是 0 和 1 \n \xa0\xa0\xa0\xa0 fib_sequence  =   [ 0 ,  1 ] \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # 如果 n 是 1，則只返回 [0] \n \xa0\xa0\xa0\xa0 if   n  = =   1 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   [ 0 ] \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # 如果 n 是 2，則返回 [0, 1] \n \xa0\xa0\xa0\xa0 if   n  = =   2 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   fib_sequence \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # 使用迴圈生成剩餘的費氏數字 \n \xa0\xa0\xa0\xa0 for   i  in   range ( 2 , n): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 next_fib  =   fib_sequence[ - 1 ]  +   fib_sequence[ - 2 ]\xa0  # 計算下個費氏數字 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fib_sequence.append(next_fib)\xa0  # 將數字加入數列 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 return   fib_sequence \n \xa0 \n # 測試函數 \n result  =   fibonacci( 5 ) \n print (result)\xa0  # 輸出: [0, 1, 1, 2, 3] \n \n \n \n \n \n \n \n 階乘計算： 寫一個函數 factorial，接受一個整數 n，並返回 n 的階乘。例如：factorial(5) 應返回 120。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n def   factorial(n): \n \xa0\xa0\xa0\xa0 # 初始階乘值為 1 \n \xa0\xa0\xa0\xa0 result  =   1 \n \xa0\xa0\xa0\xa0 # 使用 for 迴圈計算階乘 \n \xa0\xa0\xa0\xa0 for   i  in   range ( 1 , n  +   1 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  * =   i\xa0  # 將當前數字乘到結果中 \n \xa0\xa0\xa0\xa0 return   result \n \xa0 \n # 測試函數 \n result  =   factorial( 5 ) \n print (result)\xa0  # 輸出: 120 \n \n \n \n \n \n \n \n 最小公倍數： 寫一個函數 lcm，接受兩個整數 a 和 b，並返回它們的最小公倍數。例如：lcm(6, 8) 應返回 24。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n import   math \n \xa0 \n def   lcm(a, b): \n \xa0\xa0\xa0\xa0 # 計算最大公因數（GCD） \n \xa0\xa0\xa0\xa0 gcd  =   math.gcd(a, b) \n \xa0\xa0\xa0\xa0 # 計算最小公倍數（LCM） \n \xa0\xa0\xa0\xa0 return   abs (a  *   b)  / /   gcd \n \xa0 \n # 測試函數 \n result  =   lcm( 6 ,  8 ) \n print (result)\xa0  # 輸出: 24 \n \n \n \n \n \n \n \n 最大公因數： 寫一個函數 gcd，接受兩個整數 a 和 b，並返回它們的最大公因數。例如：gcd(48, 18) 應返回 6。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n \n \n \n def   gcd(a, b): \n \xa0\xa0\xa0\xa0 # 使用歐幾里得算法計算最大公因數 \n \xa0\xa0\xa0\xa0 while   b ! =   0 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 a, b  =   b, a  %   b\xa0  # 將 a 更新為 b，b 更新為 a 除以 b 的餘數 \n \xa0\xa0\xa0\xa0 return   a \n \xa0 \n # 測試函數 \n result  =   gcd( 48 ,  18 ) \n print (result)\xa0  # 輸出: 6 \n \n \n \n \n \n \n \n 階乘和： 寫一個函數 sum_of_factorials，接受一個整數 n，並返回從 1 到 n 的所有整數的階乘和。例如：sum_of_factorials(3) 應返回 9（1! + 2! + 3! = 1 + 2 + 6）。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n \n \n \n import   math \n \xa0 \n def   sum_of_factorials(n): \n \xa0\xa0\xa0\xa0 # 初始化總和為 0 \n \xa0\xa0\xa0\xa0 total_sum  =   0 \n \xa0\xa0\xa0\xa0 # 計算從 1 到 n 的所有階乘並累加 \n \xa0\xa0\xa0\xa0 for   i  in   range ( 1 , n  +   1 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 total_sum  + =   math.factorial(i)\xa0  # 計算 i 的階乘並累加 \n \xa0\xa0\xa0\xa0 return   total_sum \n \xa0 \n # 測試函數 \n result  =   sum_of_factorials( 3 ) \n print (result)\xa0  # 輸出: 9 (1! + 2! + 3! = 1 + 2 + 6) \n \n \n \n \n \n \n \n 二項式係數： 寫一個函數 binomial_coefficient，接受兩個整數 n 和 k，並返回二項式係數 "n 選 k"（n choose k）。例如：binomial_coefficient(5, 2) 應返回 10。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n \n \n \n import   math \n \xa0 \n def   binomial_coefficient(n, k): \n \xa0\xa0\xa0\xa0 # 使用二項式係數公式 C(n, k) = n! / (k! * (n-k)!) \n \xa0\xa0\xa0\xa0 return   math.factorial(n)  / /   (math.factorial(k)  *   math.factorial(n  -   k)) \n \xa0 \n # 測試函數 \n result  =   binomial_coefficient( 5 ,  2 ) \n print (result)\xa0  # 輸出: 10 \n \n \n \n \n \n', 'tags': '', 'url': '費氏數列.html'}, {'title': '清單排序', 'text': '寫一個函數 `sort_list`，接受一個包含整數的清單作為參數，並返回該清單的排序版本（從小到大）。例如：`sort_list([3, 1, 4, 1, 5])` 應返回 `[1, 1, 3, 4, 5]`。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n def   sort_list(lst): \n \xa0\xa0\xa0\xa0 # 使用內建的 sorted 函數對清單進行排序並返回排序後的清單 \n \xa0\xa0\xa0\xa0 return   sorted (lst) \n \xa0 \n # 測試函數 \n result  =   sort_list([ 3 ,  1 ,  4 ,  1 ,  5 ]) \n print (result)\xa0  # 輸出: [1, 1, 3, 4, 5] \n \n \n \n \n \n \n \n 寫一個函數 remove_duplicates，接受一個包含整數的清單作為參數，並返回去除重複元素後的清單。例如：remove_duplicates([1, 2, 2, 3, 4, 4, 5]) 應返回 [1, 2, 3, 4, 5]。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n def   remove_duplicates(lst): \n \xa0\xa0\xa0\xa0 # 使用 set() 去除重複的元素，並使用 list() 轉回清單 \n \xa0\xa0\xa0\xa0 return   list ( set (lst)) \n \xa0 \n # 測試函數 \n result  =   remove_duplicates([ 1 ,  2 ,  2 ,  3 ,  4 ,  4 ,  5 ]) \n print (result)\xa0  # 輸出: [1, 2, 3, 4, 5] \n \n \n \n \n \n \n \n 寫一個函數 reverse_list，接受一個包含整數的清單作為參數，並返回該清單的反轉版本。例如：reverse_list([1, 2, 3, 4, 5]) 應返回 [5, 4, 3, 2, 1]。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n def   reverse_list(lst): \n \xa0\xa0\xa0\xa0 # 使用內建的 reversed 函數反轉清單，並將其轉回清單 \n \xa0\xa0\xa0\xa0 return   list ( reversed (lst)) \n \xa0 \n # 測試函數 \n result  =   reverse_list([ 1 ,  2 ,  3 ,  4 ,  5 ]) \n print (result)\xa0  # 輸出: [5, 4, 3, 2, 1] \n \n \n \n \n \n \n \n 寫一個函數 find_max_min，接受一個包含整數的清單作為參數，並返回一個包含最大值和最小值的元組。例如：find_max_min([3, 1, 4, 1, 5]) 應返回 (5, 1)。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n def   find_max_min(lst): \n \xa0\xa0\xa0\xa0 # 使用內建的 max() 和 min() 函數分別獲取最大值和最小值 \n \xa0\xa0\xa0\xa0 return   ( max (lst),  min (lst)) \n \xa0 \n # 測試函數 \n result  =   find_max_min([ 3 ,  1 ,  4 ,  1 ,  5 ]) \n print (result)\xa0  # 輸出: (5, 1) \n \n \n \n \n \n \n \n 寫一個函數 cumulative_sum，接受一個包含整數的清單作為參數，並返回該清單的累積和清單。例如：cumulative_sum([1, 2, 3, 4]) 應返回 [1, 3, 6, 10]。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n \n \n \n def   cumulative_sum(lst): \n \xa0\xa0\xa0\xa0 # 初始化一個空清單來存儲累積和 \n \xa0\xa0\xa0\xa0 result  =   [] \n \xa0\xa0\xa0\xa0 # 變數來記錄當前的累積和 \n \xa0\xa0\xa0\xa0 total  =   0 \n \xa0\xa0\xa0\xa0 # 遍歷原清單，並計算累積和 \n \xa0\xa0\xa0\xa0 for   num  in   lst: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 total  + =   num\xa0  # 將當前數字加到累積和 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result.append(total)\xa0  # 將累積和添加到結果清單 \n \xa0\xa0\xa0\xa0 return   result \n \xa0 \n # 測試函數 \n result  =   cumulative_sum([ 1 ,  2 ,  3 ,  4 ]) \n print (result)\xa0  # 輸出: [1, 3, 6, 10] \n \n \n \n \n \n \n \n 寫一個函數 count_elements，接受一個包含整數的清單作為參數，並返回一個字典，該字典包含清單中每個元素出現的次數。例如：count_elements([1, 2, 2, 3, 3, 3]) 應返回 {1: 1, 2: 2, 3: 3}。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n \n \n \n def   count_elements(lst): \n \xa0\xa0\xa0\xa0 # 初始化一個空字典來存儲每個元素的出現次數 \n \xa0\xa0\xa0\xa0 count_dict  =   {} \n \xa0\xa0\xa0\xa0 # 遍歷清單中的每個元素 \n \xa0\xa0\xa0\xa0 for   num  in   lst: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 如果元素已存在於字典中，則累加其出現次數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   num  in   count_dict: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count_dict[num]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 如果元素不存在於字典中，則設置其初始出現次數為 1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count_dict[num]  =   1 \n \xa0\xa0\xa0\xa0 return   count_dict \n \xa0 \n # 測試函數 \n result  =   count_elements([ 1 ,  2 ,  2 ,  3 ,  3 ,  3 ]) \n print (result)\xa0  # 輸出: {1: 1, 2: 2, 3: 3} \n \n \n \n \n \n', 'tags': '', 'url': '清單排序.html'}, {'title': '字母計數器', 'text': '寫一個函數 `count_letters`，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個字母出現的次數。例如：`count_letters("hello")` 應返回 `{\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1}`。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n def   count_letters(s): \n \xa0\xa0\xa0\xa0 letter_count  =   {}\xa0  # 初始化空字典用來存放字母出現次數 \n \xa0\xa0\xa0\xa0 for   letter  in   s: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   letter  in   letter_count:\xa0  # 如果字母已經在字典中，則增加其次數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 letter_count[letter]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 letter_count[letter]  =   1 \xa0  # 如果字母不在字典中，則設為1 \n \xa0\xa0\xa0\xa0 return   letter_count\xa0  # 返回字母及其次數的字典 \n \xa0 \n # 測試函數 \n print (count_letters( "hello" ))\xa0  # 輸出: {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} \n \n \n \n \n \n \n \n 寫一個函數 letter_positions，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個字母出現的位置列表。例如：letter_positions("hello") 應返回 {\'h\': [0], \'e\': [1], \'l\': [2, 3], \'o\': [4]}。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n def   letter_positions(s): \n \xa0\xa0\xa0\xa0 positions  =   {}\xa0  # 初始化空字典用來存放字母的位置 \n \xa0\xa0\xa0\xa0 for   index, letter  in   enumerate (s):\xa0  # 使用 enumerate() 獲取字母和其位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   letter  in   positions:\xa0  # 如果字母已經在字典中，則將位置添加到列表中 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 positions[letter].append(index) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 positions[letter]  =   [index]\xa0  # 如果字母不在字典中，則創建位置列表 \n \xa0\xa0\xa0\xa0 return   positions\xa0  # 返回字母及其位置的字典 \n \xa0 \n # 測試函數 \n print (letter_positions( "hello" ))\xa0  # 輸出: {\'h\': [0], \'e\': [1], \'l\': [2, 3], \'o\': [4]} \n \n \n \n \n \n \n \n 寫一個函數 first_last_count，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個字母在首尾位置出現的次數。例如：first_last_count("hello world") 應返回 {\'h\': 1, \'d\': 1, \'o\': 2, \'w\': 1, \'r\': 1}。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n \n \n \n def   first_last_count(s): \n \xa0\xa0\xa0\xa0 count  =   {}\xa0  # 初始化空字典用來存放字母出現次數 \n \xa0\xa0\xa0\xa0 if   s:\xa0  # 檢查字串是否非空 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 確保首尾字母被計算 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 first  =   s[ 0 ]\xa0  # 字串的首字母 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last  =   s[ - 1 ]\xa0  # 字串的尾字母 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 處理首字母 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   first  in   count: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count[first]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count[first]  =   1 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 處理尾字母 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   last  in   count: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count[last]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count[last]  =   1 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 如果首尾字母相同，則不重複計數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   first ! =   last: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 檢查中間部分字母 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   letter  in   s[ 1 : - 1 ]:\xa0  # 遍歷首尾字母之間的字符 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   letter  in   count: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count[letter]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 count[letter]  =   1 \n \xa0 \n \xa0\xa0\xa0\xa0 return   count\xa0  # 返回字母出現次數的字典 \n \xa0 \n # 測試函數 \n print (first_last_count( "hello world" ))\xa0  # 輸出: {\'h\': 1, \'d\': 1, \'o\': 2, \'w\': 1, \'r\': 1} \n \n \n \n \n \n \n \n 寫一個函數 count_uppercase_letters，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個大寫字母出現的次數。例如：count_uppercase_letters("Hello World") 應返回 {\'H\': 1, \'W\': 1}。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n \n \n \n def   count_uppercase_letters(s): \n \xa0\xa0\xa0\xa0 uppercase_count  =   {}\xa0  # 初始化空字典用來存放大寫字母出現次數 \n \xa0\xa0\xa0\xa0 for   letter  in   s: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   letter.isupper():\xa0  # 檢查字母是否為大寫字母 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   letter  in   uppercase_count:\xa0  # 如果大寫字母已經出現過，則增加次數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 uppercase_count[letter]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 uppercase_count[letter]  =   1 \xa0  # 如果大寫字母是第一次出現，則設為1 \n \xa0\xa0\xa0\xa0 return   uppercase_count\xa0  # 返回包含大寫字母出現次數的字典 \n \xa0 \n # 測試函數 \n print (count_uppercase_letters( "Hello World" ))\xa0  # 輸出: {\'H\': 1, \'W\': 1} \n \n \n \n \n \n \n \n 寫一個函數 count_vowels，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個母音出現的次數。例如：count_vowels("hello world") 應返回 {\'e\': 1, \'o\': 2}。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n \n \n \n def   count_vowels(s): \n \xa0\xa0\xa0\xa0 vowels  =   "aeiou" \xa0  # 定義母音字母 \n \xa0\xa0\xa0\xa0 vowel_count  =   {}\xa0  # 初始化空字典用來存放母音的出現次數 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 for   letter  in   s: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   letter  in   vowels:\xa0  # 檢查字母是否是母音 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   letter  in   vowel_count:\xa0  # 如果母音已經出現過，則增加次數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vowel_count[letter]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vowel_count[letter]  =   1 \xa0  # 如果母音是第一次出現，則設為1 \n \xa0\xa0\xa0\xa0 return   vowel_count\xa0  # 返回母音及其出現次數的字典 \n \xa0 \n # 測試函數 \n print (count_vowels( "hello world" ))\xa0  # 輸出: {\'e\': 1, \'o\': 2} \n \n \n \n \n \n \n \n 寫一個函數 count_non_letter_characters，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個非字母符號出現的次數。例如：count_non_letter_characters("hello world!") 應返回 {\' \': 1, \'!\': 1}。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n \n \n \n def   count_non_letter_characters(s): \n \xa0\xa0\xa0\xa0 non_letters_count  =   {}\xa0  # 初始化空字典用來存放非字母字符的出現次數 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 for   char  in   s: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   not   char.isalpha():\xa0  # 檢查字符是否為非字母 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   char  in   non_letters_count:\xa0  # 如果字符已經在字典中，則增加次數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 non_letters_count[char]  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 non_letters_count[char]  =   1 \xa0  # 如果字符是第一次出現，則設為1 \n \xa0\xa0\xa0\xa0 return   non_letters_count\xa0  # 返回非字母字符及其出現次數的字典 \n \xa0 \n # 測試函數 \n print (count_non_letter_characters( "hello world!" ))\xa0  # 輸出: {\' \': 1, \'!\': 1} \n \n \n \n \n \n', 'tags': '', 'url': '字母計數器.html'}, {'title': '進階Brython 繪圖', 'text': '繪製同心圓： \n 使用 for 迴圈和 if 條件，在畫布上繪製一組同心圓。每個圓的中心點相同，半徑隨著循環遞增。例如，繪製 10 個半徑從 10 到 100 的同心圓，每次增加 10。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n \n \n \n import   turtle \n \xa0 \n def   draw_concentric_circles(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，以便移動到起始位置 \n \xa0 \n \xa0\xa0\xa0\xa0 # 設定圓的中心點 \n \xa0\xa0\xa0\xa0 turtle.goto( 0 ,  - 100 )\xa0  # 移動到圓心位置，y 軸往下偏移 \n \xa0 \n \xa0\xa0\xa0\xa0 # 繪製10個同心圓，半徑從10到100，每次增加10 \n \xa0\xa0\xa0\xa0 for   radius  in   range ( 10 ,  101 ,  10 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.goto( 0 ,  - radius)\xa0  # 每次繪製圓之前，移動到新的圓心 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆開始繪製 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.circle(radius)\xa0  # 繪製圓 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，準備移動到下一個圓心 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製同心圓 \n draw_concentric_circles() \n \n \n \n \n \n \n \n \n 棋盤格圖案： \n 使用 for 迴圈和 if 條件，在畫布上繪製一個 8x8 的棋盤格圖案。每個格子為正方形，黑白相間。需要根據格子的行數和列數來決定格子的顏色。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n \n \n \n import   turtle \n \xa0 \n def   draw_chessboard(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，以便移動到起始位置 \n \xa0\xa0\xa0\xa0 start_x  =   - 200 \xa0  # 棋盤的起始 x 座標 \n \xa0\xa0\xa0\xa0 start_y  =   200 \xa0  # 棋盤的起始 y 座標 \n \xa0\xa0\xa0\xa0 square_size  =   50 \xa0  # 每個正方形的大小 \n \xa0 \n \xa0\xa0\xa0\xa0 for   row  in   range ( 8 ):\xa0  # 8 行 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   col  in   range ( 8 ):\xa0  # 8 列 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 計算每個格子的顏色，根據行列的總和判斷顏色 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (row  +   col)  %   2   = =   0 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.color( "white" )\xa0  # 白色 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.color( "black" )\xa0  # 黑色 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 移動到當前格子的起始位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.goto(start_x  +   col  *   square_size, start_y  -   row  *   square_size) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆，開始繪製 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 繪製正方形 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   _  in   range ( 4 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward(square_size)\xa0  # 畫一條邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.right( 90 )\xa0  # 轉90度，畫下一條邊 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，準備畫下一個格子 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製棋盤格圖案 \n draw_chessboard() \n \n \n \n \n \n \n \n 螺旋線條： \n 使用 for 迴圈和基本數列，在畫布上繪製一個螺旋線條。每次迴圈增加線條的長度和角度。例如，從中心點開始，每次畫一段直線，長度增加 5 像素，角度增加 10 度。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n \n \n \n import   turtle \n \xa0 \n def   draw_spiral(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，移動到起始位置 \n \xa0\xa0\xa0\xa0 turtle.goto( 0 ,  0 )\xa0  # 移動到畫布中心點 \n \xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆開始繪製 \n \xa0 \n \xa0\xa0\xa0\xa0 length  =   5 \xa0  # 初始線條長度 \n \xa0\xa0\xa0\xa0 angle  =   10 \xa0\xa0  # 每次旋轉的角度 \n \xa0 \n \xa0\xa0\xa0\xa0 for   _  in   range ( 50 ):\xa0  # 繪製50次，形成螺旋線條 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward(length)\xa0  # 繪製當前長度的線段 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.right(angle)\xa0  # 旋轉指定的角度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 length  + =   5 \xa0  # 每次迴圈增加5像素的長度 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製螺旋線條 \n draw_spiral() \n \n \n \n \n \n \n \n 多邊形繪製： \n 使用 for 迴圈和 if 條件，在畫布上繪製不同邊數的正多邊形（例如：三角形、正方形、五邊形等）。例如，繪製 3 到 10 邊的多邊形，每個多邊形的邊數隨著循環遞增。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n \n \n \n import   turtle \n \xa0 \n def   draw_polygons(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，以便移動到起始位置 \n \xa0\xa0\xa0\xa0 turtle.goto( - 150 ,  100 )\xa0  # 設定起始位置 \n \xa0 \n \xa0\xa0\xa0\xa0 for   sides  in   range ( 3 ,  11 ):\xa0  # 從 3 邊到 10 邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆開始繪製 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 angle  =   360   /   sides\xa0  # 計算每個角度（360° 除以邊數） \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   _  in   range (sides):\xa0  # 繪製每個多邊形的每一條邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward( 100 )\xa0  # 繪製邊長 100 單位 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.left(angle)\xa0  # 旋轉至下一個角度 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，準備移動到下一個多邊形位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward( 150 )\xa0  # 移動到下一個多邊形的繪製位置 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製不同邊數的正多邊形 \n draw_polygons() \n \n \n \n \n \n \n \n 隨機顏色的圓形： \n 使用 for 迴圈和 if 條件，在畫布上隨機位置繪製不同顏色的圓形。每次迴圈生成一個隨機的位置和顏色，並在該位置繪製一個圓形。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n \n \n \n import   turtle \n import   random \n \xa0 \n def   draw_random_circles(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆 \n \xa0 \n \xa0\xa0\xa0\xa0 colors  =   [ "red" ,  "green" ,  "blue" ,  "yellow" ,  "purple" ,  "orange" ,  "pink" ,  "cyan" ,  "magenta" ]\xa0  # 顏色列表 \n \xa0 \n \xa0\xa0\xa0\xa0 for   _  in   range ( 20 ):\xa0  # 繪製 20 個圓形 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 隨機選擇顏色 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 color  =   random.choice(colors) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.color(color) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 隨機選擇圓形的位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 x  =   random.randint( - 300 ,  300 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 y  =   random.randint( - 300 ,  300 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.goto(x, y) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆開始繪製 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 繪製圓形，半徑 30 單位 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.begin_fill()\xa0  # 開始填充顏色 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.circle( 30 )\xa0  # 繪製圓形，半徑 30 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.end_fill()\xa0  # 結束填充顏色 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，準備繪製下一個圓形 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製隨機顏色的圓形 \n draw_random_circles() \n \n \n \n \n \n \n \n 雪花圖案： \n 使用 for 迴圈和基本數列，在畫布上繪製一個簡單的雪花圖案。雪花的每個枝條對稱排列，例如從中心向外延伸的六條對稱直線。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n \n \n \n import   turtle \n \xa0 \n def   draw_snowflake(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆 \n \xa0\xa0\xa0\xa0 turtle.goto( 0 ,  0 )\xa0  # 移動到畫布中心 \n \xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆 \n \xa0 \n \xa0\xa0\xa0\xa0 for   _  in   range ( 6 ):\xa0  # 繪製6條對稱的枝條 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward( 100 )\xa0  # 向前畫一條直線，長度為100 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.backward( 100 )\xa0  # 返回到中心 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.left( 60 )\xa0  # 旋轉60度，繪製下一條直線 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製雪花圖案 \n draw_snowflake() \n \n \n \n \n \n \n \n 旋轉方形： \n 使用 for 迴圈和基本數列，在畫布上繪製一組旋轉的方形。每次迴圈方形的角度隨著循環增加，例如每次增加 15 度，並且每個方形中心相同。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n \n \n \n import   turtle \n \xa0 \n def   draw_rotating_squares(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆 \n \xa0\xa0\xa0\xa0 turtle.goto( 0 ,  0 )\xa0  # 移動到畫布中心 \n \xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆 \n \xa0 \n \xa0\xa0\xa0\xa0 for   angle  in   range ( 0 ,  360 ,  15 ):\xa0  # 從 0 到 360，每次增加 15 度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.setheading(angle)\xa0  # 設定畫筆的朝向（角度） \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 繪製方形 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   _  in   range ( 4 ):\xa0  # 方形有四條邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward( 100 )\xa0  # 每條邊長度 100 單位 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.left( 90 )\xa0  # 轉 90 度，形成直角 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製旋轉的方形 \n draw_rotating_squares() \n \n \n \n \n \n \n \n 備註：漸變色矩形要使用IDE( 該環境不支持圖形界面 ) \n 使用 for 迴圈和基本數列，在畫布上繪製一組漸變色的矩形。每個矩形的顏色隨著循環變化，例如從紅色逐漸變為藍色。 \n turtle.Screen()._colorstr \xa0 這個方法是內部私有方法，不適合直接使用來獲取顏色的 RGB 值 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n \n \n \n import   turtle \n \xa0 \n # 顏色漸變的計算函數 \n def   interpolate_color(start_color, end_color, factor): \n \xa0\xa0\xa0\xa0 # 將顏色從字符串轉換為 RGB \n \xa0\xa0\xa0\xa0 start_rgb  =   turtle.Screen()._colorstr(start_color) \n \xa0\xa0\xa0\xa0 end_rgb  =   turtle.Screen()._colorstr(end_color) \n \xa0 \n \xa0\xa0\xa0\xa0 # 計算漸變顏色 \n \xa0\xa0\xa0\xa0 r  =   start_rgb[ 0 ]  +   factor  *   (end_rgb[ 0 ]  -   start_rgb[ 0 ]) \n \xa0\xa0\xa0\xa0 g  =   start_rgb[ 1 ]  +   factor  *   (end_rgb[ 1 ]  -   start_rgb[ 1 ]) \n \xa0\xa0\xa0\xa0 b  =   start_rgb[ 2 ]  +   factor  *   (end_rgb[ 2 ]  -   start_rgb[ 2 ]) \n \xa0 \n \xa0\xa0\xa0\xa0 return   r, g, b \n \xa0 \n def   draw_gradient_rectangles(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆 \n \xa0\xa0\xa0\xa0 turtle.goto( - 150 ,  0 )\xa0  # 移動到起始位置 \n \xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆 \n \xa0 \n \xa0\xa0\xa0\xa0 start_color  =   "red" \xa0  # 起始顏色 \n \xa0\xa0\xa0\xa0 end_color  =   "blue" \xa0  # 結束顏色 \n \xa0 \n \xa0\xa0\xa0\xa0 for   i  in   range ( 10 ):\xa0  # 繪製 10 個矩形 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 計算顏色漸變 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 factor  =   i  /   9 \xa0  # 計算漸變因子，從 0 到 1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 color  =   interpolate_color(start_color, end_color, factor) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.color(color)\xa0  # 設定顏色 \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 繪製矩形 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   _  in   range ( 2 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward( 100   +   i  *   10 )\xa0  # 每次增加 10 像素的長度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.left( 90 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward( 50   +   i  *   5 )\xa0  # 每次增加 5 像素的寬度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.left( 90 ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.penup() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.goto( - 150   +   (i  +   1 )  *   10 ,  0 )\xa0  # 移動到下一個位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.pendown() \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製漸變色矩形 \n draw_gradient_rectangles() \n \n \n \n \n \n \n \n 修正後程式： 星星圖案： \n 使用 for 迴圈和 if 條件，在畫布上繪製一組星星圖案。每次迴圈在隨機位置繪製一個五角星，星星的大小也可以隨機變化。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n \n \n \n import   turtle \n import   random \n \xa0 \n def   draw_star(x, y, size): \n \xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆，準備移動到指定位置 \n \xa0\xa0\xa0\xa0 turtle.goto(x, y)\xa0  # 移動到指定位置 \n \xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.begin_fill()\xa0  # 開始填充顏色 \n \xa0 \n \xa0\xa0\xa0\xa0 for   _  in   range ( 5 ):\xa0  # 繪製五角星的五條邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward(size)\xa0  # 向前畫一條邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.right( 144 )\xa0  # 轉動144度，繪製星星的角度 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.end_fill()\xa0  # 結束填充顏色 \n \xa0 \n def   draw_random_stars(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.bgcolor( "black" )\xa0  # 設定背景為黑色，使星星顯得更加明顯 \n \xa0 \n \xa0\xa0\xa0\xa0 for   _  in   range ( 20 ):\xa0  # 繪製 20 顆隨機位置和大小的星星 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 x  =   random.randint( - 300 ,  300 )\xa0  # 隨機生成 x 坐標 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 y  =   random.randint( - 300 ,  300 )\xa0  # 隨機生成 y 坐標 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 size  =   random.randint( 10 ,  30 )\xa0  # 隨機生成星星的大小 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 draw_star(x, y, size)\xa0  # 在隨機位置繪製星星 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製星星圖案 \n draw_random_stars() \n \n \n \n \n \n \n \n 曼陀羅圖案： \n 使用 for 迴圈和基本數列，在畫布上繪製一個簡單的曼陀羅圖案。曼陀羅圖案是一種對稱的幾何圖案，可以由多個同心圓和圓周上的線條組成，每個線條從中心點向外對稱分佈。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n \n \n \n import   turtle \n \xa0 \n def   draw_mandala(): \n \xa0\xa0\xa0\xa0 turtle.speed( 0 )\xa0  # 設定畫筆速度為最快 \n \xa0\xa0\xa0\xa0 turtle.bgcolor( "white" )\xa0  # 設定背景顏色為白色 \n \xa0 \n \xa0\xa0\xa0\xa0 # 繪製同心圓和圓周上的對稱線條 \n \xa0\xa0\xa0\xa0 for   i  in   range ( 6 ):\xa0  # 繪製六個同心圓 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.goto( 0 ,  - 20   *   (i  +   1 ))\xa0  # 每次將畫筆移到新的圓心位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.circle( 20   *   (i  +   1 ))\xa0  # 繪製圓，半徑隨著循環增大 \n \xa0 \n \xa0\xa0\xa0\xa0 # 繪製圓周上的對稱線條 \n \xa0\xa0\xa0\xa0 for   i  in   range ( 12 ):\xa0  # 繪製 12 條對稱線條 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.penup()\xa0  # 抬起畫筆 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.goto( 0 ,  0 )\xa0  # 回到中心點 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.setheading(i  *   30 )\xa0  # 設定角度，每次增加 30 度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.pendown()\xa0  # 放下畫筆 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 turtle.forward( 200 )\xa0  # 畫線條 \n \xa0 \n \xa0\xa0\xa0\xa0 turtle.done()\xa0  # 完成繪圖 \n \xa0 \n # 呼叫函數來繪製曼陀羅圖案 \n draw_mandala() \n \n \n \n \n \n', 'tags': '', 'url': '進階Brython 繪圖.html'}, {'title': '基礎Brython 繪圖', 'text': "繪製直線： 使用簡單的 for 迴圈繪製若干條平行的直線，例如從畫布的左邊到右邊，每次增加固定的間距。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n \n \n \n import   matplotlib.pyplot as plt \n \xa0 \n # 設定畫布 \n plt.figure(figsize = ( 6 ,  6 )) \n \xa0 \n # 設定直線的數量與間距 \n num_lines  =   10 \xa0  # 直線的數量 \n line_spacing  =   0.1 \xa0  # 直線的垂直間距 \n \xa0 \n # 使用 for 迴圈繪製平行直線 \n for   i  in   range (num_lines): \n \xa0\xa0\xa0\xa0 y  =   i  *   line_spacing\xa0  # 計算每條直線的 y 座標 \n \xa0\xa0\xa0\xa0 plt.plot([ 0 ,  1 ], [y, y], color = 'blue' )\xa0  # 繪製從左到右的直線 \n \xa0 \n # 設定畫布顯示範圍 \n plt.xlim( 0 ,  1 ) \n plt.ylim( 0 , (num_lines  -   1 )  *   line_spacing) \n \xa0 \n # 顯示繪製結果 \n plt.title( 'Parallel Lines' ) \n plt.xlabel( 'X-axis' ) \n plt.ylabel( 'Y-axis' ) \n plt.show() \n \n \n \n \n \n \n \n 繪製矩形： 使用 for 迴圈在畫布上繪製若干個矩形，每次增加固定的間距和尺寸。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 繪製矩形的函數 \n def   draw_rectangle(width, height): \n \xa0\xa0\xa0\xa0 for   _  in   range ( 2 ):\xa0  # 每個矩形有四條邊，繪製兩次來形成矩形 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.forward(width)\xa0  # 向前移動指定的寬度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.left( 90 )\xa0  # 轉90度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.forward(height)\xa0  # 向前移動指定的高度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.left( 90 )\xa0  # 轉90度 \n \xa0 \n # 使用 for 迴圈繪製若干個矩形 \n initial_width  =   50 \xa0  # 初始矩形寬度 \n initial_height  =   30 \xa0  # 初始矩形高度 \n spacing  =   20 \xa0  # 矩形間距 \n num_rectangles  =   5 \xa0  # 矩形數量 \n \xa0 \n # 繪製矩形 \n for   i  in   range (num_rectangles): \n \xa0\xa0\xa0\xa0 draw_rectangle(initial_width  +   i  *   spacing, initial_height  +   i  *   spacing)\xa0  # 隨著每個迴圈增加寬度和高度 \n \xa0\xa0\xa0\xa0 pen.penup()\xa0  # 抬起筆，移動到下一個起始位置 \n \xa0\xa0\xa0\xa0 pen.forward(spacing)\xa0  # 向前移動間距 \n \xa0\xa0\xa0\xa0 pen.pendown()\xa0  # 放下筆繼續繪製 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製圓形： 使用 for 迴圈在畫布上繪製若干個圓形，每次增加固定的半徑和位置。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 繪製圓形的函數 \n def   draw_circle(radius): \n \xa0\xa0\xa0\xa0 pen.circle(radius)\xa0  # 根據給定的半徑繪製圓形 \n \xa0 \n # 使用 for 迴圈繪製若干個圓形 \n initial_radius  =   20 \xa0  # 初始圓形半徑 \n radius_increase  =   20 \xa0  # 每次增長的半徑 \n num_circles  =   5 \xa0  # 圓形數量 \n \xa0 \n # 繪製圓形 \n for   i  in   range (num_circles): \n \xa0\xa0\xa0\xa0 pen.penup()\xa0  # 抬起筆，準備移動到下一個圓形位置 \n \xa0\xa0\xa0\xa0 pen.setposition( 0 ,  -   (initial_radius  +   i  *   radius_increase))\xa0  # 設定圓形的中心位置 \n \xa0\xa0\xa0\xa0 pen.pendown()\xa0  # 放下筆開始繪製 \n \xa0\xa0\xa0\xa0 draw_circle(initial_radius  +   i  *   radius_increase)\xa0  # 隨著每次迴圈增加圓形半徑 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製不同顏色的線條： 使用 for 迴圈在畫布上繪製若干條不同顏色的線條，每次改變顏色。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 定義顏色列表 \n colors  =   [ 'red' ,  'green' ,  'blue' ,  'yellow' ,  'purple' ] \n \xa0 \n # 使用 for 迴圈繪製不同顏色的線條 \n num_lines  =   len (colors)\xa0  # 線條的數量等於顏色的數量 \n \xa0 \n # 繪製不同顏色的線條 \n for   i  in   range (num_lines): \n \xa0\xa0\xa0\xa0 pen.penup()\xa0  # 抬起筆，準備移動到下一個起始位置 \n \xa0\xa0\xa0\xa0 pen.setposition( - 200   +   i  *   100 ,  0 )\xa0  # 設定每條線的起始位置 \n \xa0\xa0\xa0\xa0 pen.pendown()\xa0  # 放下筆開始繪製 \n \xa0\xa0\xa0\xa0 pen.pencolor(colors[i])\xa0  # 設定當前線條的顏色 \n \xa0\xa0\xa0\xa0 pen.forward( 100 )\xa0  # 繪製線條 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製格子圖案： 使用 for 迴圈和 if 條件在畫布上繪製簡單的格子圖案，例如 4x4 的格子，每個格子是正方形。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 定義繪製正方形的函數 \n def   draw_square(size): \n \xa0\xa0\xa0\xa0 for   _  in   range ( 4 ):\xa0  # 每個正方形有四邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.forward(size)\xa0  # 向前畫一邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.left( 90 )\xa0  # 轉90度 \n \xa0 \n # 設定格子的大小與間距 \n square_size  =   50 \xa0  # 每個正方形的邊長 \n spacing  =   10 \xa0  # 每個格子之間的間距 \n grid_size  =   4 \xa0  # 格子的行列數（4x4） \n \xa0 \n # 使用 for 迴圈繪製格子圖案 \n for   row  in   range (grid_size): \n \xa0\xa0\xa0\xa0 for   col  in   range (grid_size): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.penup()\xa0  # 抬起筆，準備移動到格子位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.setposition(col  *   (square_size  +   spacing),  - row  *   (square_size  +   spacing))\xa0  # 設定每個格子的位置 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.pendown()\xa0  # 放下筆開始繪製 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 draw_square(square_size)\xa0  # 繪製正方形 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製對角線： 使用 for 迴圈在畫布上繪製從左上角到右下角的對角線。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 定義繪製對角線的函數 \n def   draw_diagonal(length): \n \xa0\xa0\xa0\xa0 for   _  in   range (length):\xa0  # 循環繪製對角線 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.forward( 1 )\xa0  # 向前移動1個單位 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.left( 90 )\xa0  # 轉90度 \n \xa0 \n # 設定對角線的長度 \n line_length  =   200 \xa0  # 設定對角線的長度 \n \xa0 \n # 使用 for 迴圈繪製對角線 \n pen.penup()\xa0  # 抬起筆，準備移動到左上角 \n pen.setposition( - line_length  / /   2 , line_length  / /   2 )\xa0  # 設定起始位置（左上角） \n pen.pendown()\xa0  # 放下筆開始繪製 \n pen.setposition(line_length  / /   2 ,  - line_length  / /   2 )\xa0  # 繪製線條到右下角 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製交錯矩形： 使用 for 迴圈在畫布上繪製若干個交錯排列的矩形，形成交錯圖案。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 定義繪製矩形的函數 \n def   draw_rectangle(width, height): \n \xa0\xa0\xa0\xa0 for   _  in   range ( 2 ):\xa0  # 每個矩形有四邊，繪製兩次 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.forward(width)\xa0  # 向前移動寬度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.left( 90 )\xa0  # 轉90度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.forward(height)\xa0  # 向前移動高度 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.left( 90 )\xa0  # 轉90度 \n \xa0 \n # 設定矩形的大小與間距 \n rect_width  =   100 \xa0  # 矩形的寬度 \n rect_height  =   50 \xa0  # 矩形的高度 \n num_rectangles  =   5 \xa0  # 繪製的矩形數量 \n \xa0 \n # 使用 for 迴圈繪製交錯排列的矩形 \n for   i  in   range (num_rectangles): \n \xa0\xa0\xa0\xa0 pen.penup()\xa0  # 抬起筆，準備移動到下一個矩形位置 \n \xa0\xa0\xa0\xa0 pen.setposition( - 200   +   i  *   40 ,  200   -   i  *   20 )\xa0  # 設定每個矩形的起始位置，改變位置實現交錯 \n \xa0\xa0\xa0\xa0 pen.pendown()\xa0  # 放下筆開始繪製 \n \xa0\xa0\xa0\xa0 if   i  %   2   = =   0 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.setheading( 0 )\xa0  # 偶數索引的矩形保持水平 \n \xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.setheading( 45 )\xa0  # 奇數索引的矩形旋轉45度，實現交錯排列 \n \xa0\xa0\xa0\xa0 draw_rectangle(rect_width, rect_height)\xa0  # 繪製矩形 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製同心圓： 使用 for 迴圈在畫布上繪製若干個同心圓，每次增加固定的半徑。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 定義繪製圓形的函數 \n def   draw_circle(radius): \n \xa0\xa0\xa0\xa0 pen.circle(radius)\xa0  # 根據給定的半徑繪製圓形 \n \xa0 \n # 設定圓形的初始半徑與增長值 \n initial_radius  =   20 \xa0  # 初始圓形半徑 \n radius_increase  =   20 \xa0  # 每次增長的半徑 \n num_circles  =   5 \xa0  # 圓形數量 \n \xa0 \n # 使用 for 迴圈繪製同心圓 \n for   i  in   range (num_circles): \n \xa0\xa0\xa0\xa0 pen.penup()\xa0  # 抬起筆，準備移動到圓形中心 \n \xa0\xa0\xa0\xa0 pen.setposition( 0 ,  -   (initial_radius  +   i  *   radius_increase))\xa0  # 設定圓形的中心位置 \n \xa0\xa0\xa0\xa0 pen.pendown()\xa0  # 放下筆開始繪製 \n \xa0\xa0\xa0\xa0 draw_circle(initial_radius  +   i  *   radius_increase)\xa0  # 繪製每個同心圓，隨著每次迴圈增加半徑 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製同心方形： 使用 for 迴圈在畫布上繪製若干個同心方形，每次增加固定的邊長。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 定義繪製方形的函數 \n def   draw_square(side_length): \n \xa0\xa0\xa0\xa0 for   _  in   range ( 4 ):\xa0  # 每個方形有四條邊 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.forward(side_length)\xa0  # 向前移動邊長 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pen.left( 90 )\xa0  # 轉90度 \n \xa0 \n # 設定方形的初始邊長與增長值 \n initial_side_length  =   50 \xa0  # 初始方形邊長 \n side_length_increase  =   20 \xa0  # 每次增長的邊長 \n num_squares  =   5 \xa0  # 方形數量 \n \xa0 \n # 使用 for 迴圈繪製同心方形 \n for   i  in   range (num_squares): \n \xa0\xa0\xa0\xa0 pen.penup()\xa0  # 抬起筆，準備移動到方形的位置 \n \xa0\xa0\xa0\xa0 pen.setposition( -   (initial_side_length  +   i  *   side_length_increase)  /   2 , (initial_side_length  +   i  *   side_length_increase)  /   2 )\xa0  # 設定方形的起始位置 \n \xa0\xa0\xa0\xa0 pen.pendown()\xa0  # 放下筆開始繪製 \n \xa0\xa0\xa0\xa0 draw_square(initial_side_length  +   i  *   side_length_increase)\xa0  # 繪製每個同心方形，隨著每次迴圈增加邊長 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n 繪製簡單的線條圖： 使用 for 迴圈在畫布上繪製若干條從畫布中心向外輻射的線條。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n \n \n \n import   turtle\xa0  # 引入 turtle 模組 \n \xa0 \n # 設定畫布 \n screen  =   turtle.Screen() \n screen.setup(width = 600 , height = 600 ) \n \xa0 \n # 設定 turtle \n pen  =   turtle.Turtle() \n pen.speed( 10 )\xa0  # 設定繪圖速度 \n \xa0 \n # 定義繪製線條的函數 \n def   draw_line(length): \n \xa0\xa0\xa0\xa0 pen.forward(length)\xa0  # 向前繪製一條線條 \n \xa0 \n # 設定線條的長度與數量 \n line_length  =   200 \xa0  # 每條線條的長度 \n num_lines  =   12 \xa0  # 線條的數量（從中心向外輻射） \n \xa0 \n # 使用 for 迴圈繪製從畫布中心向外輻射的線條 \n pen.penup()\xa0  # 抬起筆，準備移動到畫布中心 \n pen.setposition( 0 ,  0 )\xa0  # 設定畫布的中心位置 \n pen.pendown()\xa0  # 放下筆開始繪製 \n \xa0 \n for   i  in   range (num_lines): \n \xa0\xa0\xa0\xa0 pen.setheading(i  *   ( 360   /   num_lines))\xa0  # 設定每條線條的角度，使其均勻分布 \n \xa0\xa0\xa0\xa0 draw_line(line_length)\xa0  # 繪製線條 \n \xa0 \n # 完成後停止 \n turtle.done() \n \n \n \n \n \n \n \n", 'tags': '', 'url': '基礎Brython 繪圖.html'}, {'title': 'Brython', 'text': '從 1 累加到 100: \n 1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束  \n \n  ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}]};